{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"This is the documentation for the PopGen.jl package. If you're reading this, you're likely interested in doing some kind of population genetics analyses. Please read through the docs and try the functions out with the test data in /test/testdata.gen to get a feel for what PopGen.jl can do. About PopGen.jl is an attempt to shift population genetics analyses away from the patchwork of available pop-gen packages present in the R and Python languages, and combine it with the speed, power, fun(?), and community of the Julia language. We hope to implement common analyses (heterozygosity, kinship, FST, Tajima's D, etc.) in sane , user friendly ways, with syntax used within the package being consistent with the rest of the Julia ecosystem. Goal To be a comprehensive package for population genetics analyses and visualization that's fast and user friendly. This project is developed with a particular mantra: Sanity, Sensibility, Accessibility . Sanity Functions are written in a way such that their use is sane and natural. When possible (or sensible), we use full words for input variables or other components of input/output. All functions in this package have their first argument as the input data without keywords. Always. We also try to minimize redundancy, such as the function remove_loci! , where the loci you wish you remove are listed as the second argument without a keyword, because the name of the function is already self explanatory, and the first argument will always be the input data, therefor having a keyword argument loci = would be redundant. Sensibility Functions need to be sensible, both in what they do and how they do it. This means that functions should include only the most relevant arguments, and the most sensible defaults for arguments. It also means the outputs need to be flexible enough to use with other Julia packages. As an example, plot_missing takes the entire PopObj as an argument rather than a user specifying specific elements, and it returns a pre-configured plot for basic data visualization. The only arguments are a custom color palette, if so desired. However, the purpose of that plot is for data exploration, so the specification of plotting attributes is unnecessary because those plots will never be in publications. If a user wants to make their own plots using that information, they can do that with the dataframes produced from missing , which is exactly what plot_missing does under the hood! Accessibility Documentation is everything! We recognize Julia is a comparatively young language, and we know which languages and packages other population geneticists are using for their work. We want you to be comfortable using PopGen.jl , and that means investing a lot of time into writing thorough documentation intended for users (vs developers). We also recognize that you (the reader) might not be very familiar with Julia, or any language other than R (which is ok!), so we've written a section on clarifying some Julia concepts/conventions that will make reading this documentation a whole lot clearer. It is by no means a replacement for sitting down and learning the Julia language a bit ( here is a great online book on that ), but it should hopefully reduce the barrier of entry somewhat. Why Julia and not Python or R? Speed and syntax The speed is comparable to C when coded correctly. Also, has Python-like syntax with optional tabs. We are also fans of 1-indexing, but that's more of a perk. A modern language for modern problems Julia has native support for: parallelization, distributed computing, GPU processing, and pipes! It also has robust machine learning packages (maybe for future implementations). Community & contribution Julia's just-in-time type-safe and optimized compiling solves what's known as the \"two language problem\". That is, languages that are easy to write in are slow, and languages that are more difficult to write in are fast. Interpreted languages, like Python, R, and Perl are easier to write in, however many of the commonly used packages and functions in those languages are written in another, faster language under the hood for performance reasons. On the whole, that's not really a problem for end-users, because functions work and they are easy to use. But , it does become a problem when you want to investigate the code and implementation of a function. This means that, even as an R power-user, you are powerless to investigate the implementation of something you are using if it's actually written in C++. In a sense, it makes the publications of those methods less reproducible, because the users of it may be familiar with the language it's deployed in (like R), but not the language it's written in, (like C++). What if there are bugs?! What if the code implementation doesn't match the formulations in the publication?! Yikes! And thus solving the two language problem, users can themselves diagnose code if they so choose. Yes, that means that we might be getting more Issues opened up, but a bug found is a lot better than a bug overlooked! Like most Julia packages, PopGen.jl is written entirely in Julia, meaning the community using it need not learn another language if they wanted to contribute! Have you written a clever Julia function to calculate SAMOVA from a PopObj ? Send us a pull request! (please!) Package manager Which is such a delight to use. Authors Pavel Dimens, PhD Student @ U. Southern Mississippi Jason Selwyn, PhD Candidate @ Texas A&M University - Corpus Christi","title":"Home"},{"location":"#about","text":"PopGen.jl is an attempt to shift population genetics analyses away from the patchwork of available pop-gen packages present in the R and Python languages, and combine it with the speed, power, fun(?), and community of the Julia language. We hope to implement common analyses (heterozygosity, kinship, FST, Tajima's D, etc.) in sane , user friendly ways, with syntax used within the package being consistent with the rest of the Julia ecosystem.","title":"About"},{"location":"#goal","text":"To be a comprehensive package for population genetics analyses and visualization that's fast and user friendly. This project is developed with a particular mantra: Sanity, Sensibility, Accessibility . Sanity Functions are written in a way such that their use is sane and natural. When possible (or sensible), we use full words for input variables or other components of input/output. All functions in this package have their first argument as the input data without keywords. Always. We also try to minimize redundancy, such as the function remove_loci! , where the loci you wish you remove are listed as the second argument without a keyword, because the name of the function is already self explanatory, and the first argument will always be the input data, therefor having a keyword argument loci = would be redundant. Sensibility Functions need to be sensible, both in what they do and how they do it. This means that functions should include only the most relevant arguments, and the most sensible defaults for arguments. It also means the outputs need to be flexible enough to use with other Julia packages. As an example, plot_missing takes the entire PopObj as an argument rather than a user specifying specific elements, and it returns a pre-configured plot for basic data visualization. The only arguments are a custom color palette, if so desired. However, the purpose of that plot is for data exploration, so the specification of plotting attributes is unnecessary because those plots will never be in publications. If a user wants to make their own plots using that information, they can do that with the dataframes produced from missing , which is exactly what plot_missing does under the hood! Accessibility Documentation is everything! We recognize Julia is a comparatively young language, and we know which languages and packages other population geneticists are using for their work. We want you to be comfortable using PopGen.jl , and that means investing a lot of time into writing thorough documentation intended for users (vs developers). We also recognize that you (the reader) might not be very familiar with Julia, or any language other than R (which is ok!), so we've written a section on clarifying some Julia concepts/conventions that will make reading this documentation a whole lot clearer. It is by no means a replacement for sitting down and learning the Julia language a bit ( here is a great online book on that ), but it should hopefully reduce the barrier of entry somewhat.","title":"Goal"},{"location":"#why-julia-and-not-python-or-r","text":"Speed and syntax The speed is comparable to C when coded correctly. Also, has Python-like syntax with optional tabs. We are also fans of 1-indexing, but that's more of a perk. A modern language for modern problems Julia has native support for: parallelization, distributed computing, GPU processing, and pipes! It also has robust machine learning packages (maybe for future implementations). Community & contribution Julia's just-in-time type-safe and optimized compiling solves what's known as the \"two language problem\". That is, languages that are easy to write in are slow, and languages that are more difficult to write in are fast. Interpreted languages, like Python, R, and Perl are easier to write in, however many of the commonly used packages and functions in those languages are written in another, faster language under the hood for performance reasons. On the whole, that's not really a problem for end-users, because functions work and they are easy to use. But , it does become a problem when you want to investigate the code and implementation of a function. This means that, even as an R power-user, you are powerless to investigate the implementation of something you are using if it's actually written in C++. In a sense, it makes the publications of those methods less reproducible, because the users of it may be familiar with the language it's deployed in (like R), but not the language it's written in, (like C++). What if there are bugs?! What if the code implementation doesn't match the formulations in the publication?! Yikes! And thus solving the two language problem, users can themselves diagnose code if they so choose. Yes, that means that we might be getting more Issues opened up, but a bug found is a lot better than a bug overlooked! Like most Julia packages, PopGen.jl is written entirely in Julia, meaning the community using it need not learn another language if they wanted to contribute! Have you written a clever Julia function to calculate SAMOVA from a PopObj ? Send us a pull request! (please!) Package manager Which is such a delight to use.","title":"Why Julia and not Python or R?"},{"location":"#authors","text":"Pavel Dimens, PhD Student @ U. Southern Mississippi Jason Selwyn, PhD Candidate @ Texas A&M University - Corpus Christi","title":"Authors"},{"location":"PopObj_accessing/","text":"A little hands-on training will probably go a long way, so let's through some of the functions available in PopGen.jl with the included data. This tutorial will include both inputs and outputs so you can be confident what you're seeing in your Julia session is exactly what's supposed to happen. Sometimes the outputs can be a little lengthy, so they will be arranged in code \"tabs\", where the left-most tab is the input named after what it's accomplishing, and the right tab is the output of running the command. Loading in the data Let's keep things simple by loading in the nancycats data and calling it ncats load nancycats julia > ncats = nancycats () ; summary ( ncats ) output Object of type PopObj: No location data provided Number of individuals: 237 [\"N215\", \"N216\", \"N217\"] \u2026 [\"N281\", \"N289\", \"N290\"] Number of loci: 9 [\"fca8\", \"fca23\", \"fca43\"] \u2026 [\"fca90\", \"fca96\", \"fca37\"] Ploidy: 2 Number of populations: 17 #Inds | Pop -------------- 10 | 1 22 | 2 12 | 3 23 | 4 15 | 5 11 | 6 14 | 7 10 | 8 9 | 9 11 | 10 20 | 11 14 | 12 13 | 13 17 | 14 11 | 15 12 | 16 13 | 17 Available fields: ind, popid, loci, ploidy, genotypes, longitude, latitude Note the last line of the output. These fields can be accessed by name using the dot . accessor. Trying out the standard accessors Now that we have nancycats loaded in, we can use standard Julia accessor conventions to view the elements within our PopObj. .ind This will access the names of the individuals as they appeared in the data. .ind julia > ncats . ind output 237-element Array{String,1}: \"N215\" \"N216\" \"N217\" \"N218\" \"N219\" \"N220\" \"N221\" \"N222\" \"N223\" \"N224\" \"N7\" \"N141\" \"N142\" \"N143\" \"N144\" \"N145\" \"N146\" \"N147\" \"N148\" \"N149\" \u22ee \"N256\" \"N257\" \"N258\" \"N259\" \"N260\" \"N261\" \"N262\" \"N282\" \"N283\" \"N288\" \"N291\" \"N292\" \"N293\" \"N294\" \"N295\" \"N296\" \"N297\" \"N281\" \"N289\" \"N290\" .popid This will access the names of the populations associated with each individual, in the same order as the individuals. .popid julia > ncats . ind output 237-element Array{Union{Int64, String},1}: \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"2\" \"2\" \"2\" \"2\" \"2\" \"2\" \"2\" \"2\" \"2\" \"2\" \u22ee \"16\" \"16\" \"16\" \"16\" \"16\" \"16\" \"16\" \"17\" \"17\" \"17\" \"17\" \"17\" \"17\" \"17\" \"17\" \"17\" \"17\" \"17\" \"17\" \"17\" These ID's aren't super informative. Later, we'll change them using the popid! command. .loci This will access the names of the loci as they appeared in the data. .loci julia > ncats . ind output 9-element Array{String,1}: \"fca8\" \"fca23\" \"fca43\" \"fca45\" \"fca77\" \"fca78\" \"fca90\" \"fca96\" \"fca37\" .ploidy This shows you the ploidy of the data, which is user-provided when loading in real data. .ploidy julia > ncats . ind output 2 .genotypes This is the core of the PopObj type and it displays a Dict of loci corresponding to an array of tuples that have the genotypes of each individual in the order with which they appear in .ind . Due to the way Dicts parse (they do not have indices), viewing .genotypes will likely show you a different order of loci each time you display it. Worry not! Their values (the genotypes) are arrays, therefor indexed, and respect the order of .ind . Under the hood, PopGen.jl uses .ind and .loci to iterate over .genotypes , so ultimately, the order of loci is respected, even though there isn't any good analytical reason for it. .genotypes julia > ncats . genotypes output # the output scales to your REPL width Dict{String,Array{Any,1}} with 9 entries: \"fca77\" => Any[(156, 156), (156, 156), (156, 152), (150, 150), (152, 152), (\u2026 \"fca96\" => Any[(113, 113), (113, 113), (113, 113), (91, 10, 5), (113, 113), \u2026 \"fca23\" => Any[(136, 146), (146, 146), (136, 146), (138, 138), (146, 140), (\u2026 \"fca78\" => Any[(142, 148), (142, 148), (142, 142), (142, 148), (142, 148), (\u2026 \"fca8\" => Any[(0, 0), (0, 0), (135, 143), (135, 133), (135, 133), (135, 143\u2026 \"fca45\" => Any[(116, 120), (120, 126), (116, 116), (116, 126), (126, 126), (\u2026 \"fca37\" => Any[(208, 208), (208, 208), (210, 210), (208, 208), (208, 208), (\u2026 \"fca43\" => Any[(139, 139), (139, 145), (141, 141), (139, 141), (145, 141), (\u2026 \"fca90\" => Any[(199, 199), (199, 185), (197, 197), (199, 199), (199, 193), (\u2026 Since genotypes is a Dict , you access it using standard Julia Dict conventions. This includes the keys and values commands, or you can access the genotypes of specific loci with square brackets and the locus name in quotes: Dict at key julia > ncats . genotypes [ \"fca8\" ] output 237-element Array{Any,1}: (0, 0) (0, 0) (135, 143) (135, 133) (135, 133) (135, 143) (135, 135) (135, 143) (143, 137) (135, 135) (137, 141) (133, 129) (133, 129) (133, 133) (135, 131) (135, 129) (133, 129) (135, 129) (135, 135) (135, 131) \u22ee (139, 139) (137, 139) (137, 139) (143, 137) (135, 139) (143, 139) (135, 139) (135, 133) (135, 133) (133, 141) (133, 141) (133, 123) (133, 123) (133, 141) (133, 141) (133, 141) (143, 133) (135, 141) (143, 137) (135, 141) .latitude This accesses the latitude information of the PopObj. If there is none, like in the nancycats data, it returns an empty array. .latitude julia > ncats . latitude output 0-element Array{Union{Float64, Int64},1} .latitude This accesses the longitude information of the PopObj. Like before, iIf there is none, like in the nancycats data, it returns an empty array. .longitude julia > ncats . longitude output 0-element Array{Union{Float64, Int64},1} Seeing some location info The nancycats data has some weird coordinate system for information, so those data were omitted. If you want a proof of concept for .longitude and .latitude , load in gulfsharks and try it out. We'll use hcat (horizontal concatination) to horizontally bind the individual names, their latitude, and longitude. Later, you'll see that the locations command does this and a bit more load gulfsharks julia > sharks = gulfsharks () ; # semicolon just supresses printing output julia > hcat ( sharks . ind , sharks . latitude , sharks . longitude ) output 212\u00d73 Array{Any,2}: \"cc_001\" 28.3062 -80.5993 \"cc_002\" 28.3079 -80.5995 \"cc_003\" 28.3023 -80.5996 \"cc_005\" 28.6123 -80.4225 \"cc_007\" 27.8666 -80.3578 \"cc_008\" 27.8666 -80.3579 \"cc_009\" 27.8682 -80.3482 \"cc_010\" 27.8711 -80.3482 \"cc_012\" 28.4815 -80.4303 \"cc_013\" 28.2421 -80.2494 \"cc_014\" 28.2428 -80.2496 \"cc_015\" 28.2378 -80.2496 \"cc_016\" 28.2414 -80.2498 \"cc_017\" 28.236 -80.2495 \"cc_018\" 28.2364 -80.2494 \"cc_019\" 28.3906 -80.4963 \"cc_020\" 28.3902 -80.4968 \"cc_021\" 28.3861 -80.4967 \"cc_022\" 28.3869 -80.4966 \"cc_023\" 28.3865 -80.496 \u22ee \"seg_001\" 29.8901 -87.7189 \"seg_003\" 30.1943 -88.0007 \"seg_009\" 30.0021 -88.0493 \"seg_010\" 30.0069 -88.049 \"seg_011\" 29.8362 -88.1675 \"seg_012\" 29.5057 -88.0546 \"seg_014\" 30.1428 -88.2974 \"seg_015\" 30.2074 -88.36 \"seg_016\" 30.1151 -88.3922 \"seg_018\" 29.8362 -88.168 \"seg_021\" 29.9466 -86.0399 \"seg_023\" 29.9969 -85.6494 \"seg_024\" 29.6966 -87.4403 \"seg_025\" 30.064 -86.5374 \"seg_026\" 30.0696 -86.5376 \"seg_027\" 29.9065 -86.0905 \"seg_028\" 30.0532 -87.3661 \"seg_029\" 30.0522 -87.3662 \"seg_030\" 29.8234 -85.7143 \"seg_031\" 29.8234 -85.7143 Slices general You can likewise use slices to access parts of these data. If you're migrating from R or Python, it's the simple bracket accessor you're already familiar with, used to pull out a range of values. Julia just calls them slices. Let's look at a slice of .ind . slice .ind julia > ncats . ind [ 1 : 6 ] output 6-element Array{String,1}: \"N215\" \"N216\" \"N217\" \"N218\" \"N219\" \"N220\" Here's another example: slice .loci julia > ncats . loci [ 3 : end ] output 7-element Array{String,1}: \"fca43\" \"fca45\" \"fca77\" \"fca78\" \"fca90\" \"fca96\" \"fca37\" :end All things start at 1, so there is no need for a special word for it. On the other hand, objects can have unknown lengths or varied lengths as you work with them. In Julia, use the word end in a slice range to indicate you want it to go to the end,, regardless of length or known size. genotypes We can do this for all the accessors, except genotypes , because it's a dictionary and has slightly different syntax. To use slices on genotypes , you will need to call the locus by name using the Dict syntax, then take a slice of that: slice genotypes julia > ncats . genotypes [ \"fca8\" ][ 1 : 3 ] output 3-element Array{Any,1}: (0, 0) (0, 0) (135, 143) Operating on accessors These accessors follow the exact same format as the dot operator in Python, or the $ operator in R, meaning these objects can be assigned to new variables, you can operate on them, iterate over them, etc. Here's a simple example to display the unique population ID's in your PopObj unique julia > unique ( ncats . popid ) output 17-element Array{Union{Int64, String},1}: \"1\" \"2\" \"3\" \"4\" \"5\" \"6\" \"7\" \"8\" \"9\" \"10\" \"11\" \"12\" \"13\" \"14\" \"15\" \"16\" \"17\" Pipes Julia has native piping (much like BASH) which uses the syntax |> (pipe + greater-than). With a pipe, unique(ncats.popid) can also be rewritten as ncats.popid |> unique for the same result. It's often a matter of preference for which you consider more readable. Use the Pipe package for even more robust piping where you can specify which argument the pipe relates to! \ud83d\uded1\u274c What to avoid! \u274c\ud83d\uded1 Given the relationships of the ordered list of individuals ( .ind ), their population ID's ( .popid ), and the order of genotypes in .genotypes , NEVER USE sort , sort! , or manually arrange/add/delete anything in .ind or popid !!! There are included functions remove_loci! and remove_inds! that do that kind of thing. That being said, you can rename individuals and their popid's without issue. Just no manual moving or deleting! Let's look at what happens when you mananually delete an individual julia> pop!(ncats.ind) \"N290\" Well, that seems benign, it removed the last individual from nancycats... Except it didn't, not fully. There is still a popid associated with that individual, and each of the 9 loci still have a genotype for it. If you had location data, it would still be there too. Now, the lengths of everything is messed up! julia> length(ncats.ind) 236 julia> length(ncats.popid) 237 julia> length(ncats.genotypes[\"fca8\"]) 237 This is obviously a problem, and if you manually delete an individual from somewhere in the middle, then all the popid s and genotypes following it are shifted one, associated with the wrong individual. You would have to manually delete all the traces of this individual, which is annoying. Instead, did that work for you with the remove_ind! command!","title":"Accessing"},{"location":"PopObj_accessing/#loading-in-the-data","text":"Let's keep things simple by loading in the nancycats data and calling it ncats load nancycats julia > ncats = nancycats () ; summary ( ncats ) output Object of type PopObj: No location data provided Number of individuals: 237 [\"N215\", \"N216\", \"N217\"] \u2026 [\"N281\", \"N289\", \"N290\"] Number of loci: 9 [\"fca8\", \"fca23\", \"fca43\"] \u2026 [\"fca90\", \"fca96\", \"fca37\"] Ploidy: 2 Number of populations: 17 #Inds | Pop -------------- 10 | 1 22 | 2 12 | 3 23 | 4 15 | 5 11 | 6 14 | 7 10 | 8 9 | 9 11 | 10 20 | 11 14 | 12 13 | 13 17 | 14 11 | 15 12 | 16 13 | 17 Available fields: ind, popid, loci, ploidy, genotypes, longitude, latitude Note the last line of the output. These fields can be accessed by name using the dot . accessor.","title":"Loading in the data"},{"location":"PopObj_accessing/#trying-out-the-standard-accessors","text":"Now that we have nancycats loaded in, we can use standard Julia accessor conventions to view the elements within our PopObj.","title":"Trying out the standard accessors"},{"location":"PopObj_accessing/#ind","text":"This will access the names of the individuals as they appeared in the data. .ind julia > ncats . ind output 237-element Array{String,1}: \"N215\" \"N216\" \"N217\" \"N218\" \"N219\" \"N220\" \"N221\" \"N222\" \"N223\" \"N224\" \"N7\" \"N141\" \"N142\" \"N143\" \"N144\" \"N145\" \"N146\" \"N147\" \"N148\" \"N149\" \u22ee \"N256\" \"N257\" \"N258\" \"N259\" \"N260\" \"N261\" \"N262\" \"N282\" \"N283\" \"N288\" \"N291\" \"N292\" \"N293\" \"N294\" \"N295\" \"N296\" \"N297\" \"N281\" \"N289\" \"N290\"","title":".ind"},{"location":"PopObj_accessing/#popid","text":"This will access the names of the populations associated with each individual, in the same order as the individuals. .popid julia > ncats . ind output 237-element Array{Union{Int64, String},1}: \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"2\" \"2\" \"2\" \"2\" \"2\" \"2\" \"2\" \"2\" \"2\" \"2\" \u22ee \"16\" \"16\" \"16\" \"16\" \"16\" \"16\" \"16\" \"17\" \"17\" \"17\" \"17\" \"17\" \"17\" \"17\" \"17\" \"17\" \"17\" \"17\" \"17\" \"17\" These ID's aren't super informative. Later, we'll change them using the popid! command.","title":".popid"},{"location":"PopObj_accessing/#loci","text":"This will access the names of the loci as they appeared in the data. .loci julia > ncats . ind output 9-element Array{String,1}: \"fca8\" \"fca23\" \"fca43\" \"fca45\" \"fca77\" \"fca78\" \"fca90\" \"fca96\" \"fca37\"","title":".loci"},{"location":"PopObj_accessing/#ploidy","text":"This shows you the ploidy of the data, which is user-provided when loading in real data. .ploidy julia > ncats . ind output 2","title":".ploidy"},{"location":"PopObj_accessing/#genotypes","text":"This is the core of the PopObj type and it displays a Dict of loci corresponding to an array of tuples that have the genotypes of each individual in the order with which they appear in .ind . Due to the way Dicts parse (they do not have indices), viewing .genotypes will likely show you a different order of loci each time you display it. Worry not! Their values (the genotypes) are arrays, therefor indexed, and respect the order of .ind . Under the hood, PopGen.jl uses .ind and .loci to iterate over .genotypes , so ultimately, the order of loci is respected, even though there isn't any good analytical reason for it. .genotypes julia > ncats . genotypes output # the output scales to your REPL width Dict{String,Array{Any,1}} with 9 entries: \"fca77\" => Any[(156, 156), (156, 156), (156, 152), (150, 150), (152, 152), (\u2026 \"fca96\" => Any[(113, 113), (113, 113), (113, 113), (91, 10, 5), (113, 113), \u2026 \"fca23\" => Any[(136, 146), (146, 146), (136, 146), (138, 138), (146, 140), (\u2026 \"fca78\" => Any[(142, 148), (142, 148), (142, 142), (142, 148), (142, 148), (\u2026 \"fca8\" => Any[(0, 0), (0, 0), (135, 143), (135, 133), (135, 133), (135, 143\u2026 \"fca45\" => Any[(116, 120), (120, 126), (116, 116), (116, 126), (126, 126), (\u2026 \"fca37\" => Any[(208, 208), (208, 208), (210, 210), (208, 208), (208, 208), (\u2026 \"fca43\" => Any[(139, 139), (139, 145), (141, 141), (139, 141), (145, 141), (\u2026 \"fca90\" => Any[(199, 199), (199, 185), (197, 197), (199, 199), (199, 193), (\u2026 Since genotypes is a Dict , you access it using standard Julia Dict conventions. This includes the keys and values commands, or you can access the genotypes of specific loci with square brackets and the locus name in quotes: Dict at key julia > ncats . genotypes [ \"fca8\" ] output 237-element Array{Any,1}: (0, 0) (0, 0) (135, 143) (135, 133) (135, 133) (135, 143) (135, 135) (135, 143) (143, 137) (135, 135) (137, 141) (133, 129) (133, 129) (133, 133) (135, 131) (135, 129) (133, 129) (135, 129) (135, 135) (135, 131) \u22ee (139, 139) (137, 139) (137, 139) (143, 137) (135, 139) (143, 139) (135, 139) (135, 133) (135, 133) (133, 141) (133, 141) (133, 123) (133, 123) (133, 141) (133, 141) (133, 141) (143, 133) (135, 141) (143, 137) (135, 141)","title":".genotypes"},{"location":"PopObj_accessing/#latitude","text":"This accesses the latitude information of the PopObj. If there is none, like in the nancycats data, it returns an empty array. .latitude julia > ncats . latitude output 0-element Array{Union{Float64, Int64},1}","title":".latitude"},{"location":"PopObj_accessing/#latitude_1","text":"This accesses the longitude information of the PopObj. Like before, iIf there is none, like in the nancycats data, it returns an empty array. .longitude julia > ncats . longitude output 0-element Array{Union{Float64, Int64},1} Seeing some location info The nancycats data has some weird coordinate system for information, so those data were omitted. If you want a proof of concept for .longitude and .latitude , load in gulfsharks and try it out. We'll use hcat (horizontal concatination) to horizontally bind the individual names, their latitude, and longitude. Later, you'll see that the locations command does this and a bit more load gulfsharks julia > sharks = gulfsharks () ; # semicolon just supresses printing output julia > hcat ( sharks . ind , sharks . latitude , sharks . longitude ) output 212\u00d73 Array{Any,2}: \"cc_001\" 28.3062 -80.5993 \"cc_002\" 28.3079 -80.5995 \"cc_003\" 28.3023 -80.5996 \"cc_005\" 28.6123 -80.4225 \"cc_007\" 27.8666 -80.3578 \"cc_008\" 27.8666 -80.3579 \"cc_009\" 27.8682 -80.3482 \"cc_010\" 27.8711 -80.3482 \"cc_012\" 28.4815 -80.4303 \"cc_013\" 28.2421 -80.2494 \"cc_014\" 28.2428 -80.2496 \"cc_015\" 28.2378 -80.2496 \"cc_016\" 28.2414 -80.2498 \"cc_017\" 28.236 -80.2495 \"cc_018\" 28.2364 -80.2494 \"cc_019\" 28.3906 -80.4963 \"cc_020\" 28.3902 -80.4968 \"cc_021\" 28.3861 -80.4967 \"cc_022\" 28.3869 -80.4966 \"cc_023\" 28.3865 -80.496 \u22ee \"seg_001\" 29.8901 -87.7189 \"seg_003\" 30.1943 -88.0007 \"seg_009\" 30.0021 -88.0493 \"seg_010\" 30.0069 -88.049 \"seg_011\" 29.8362 -88.1675 \"seg_012\" 29.5057 -88.0546 \"seg_014\" 30.1428 -88.2974 \"seg_015\" 30.2074 -88.36 \"seg_016\" 30.1151 -88.3922 \"seg_018\" 29.8362 -88.168 \"seg_021\" 29.9466 -86.0399 \"seg_023\" 29.9969 -85.6494 \"seg_024\" 29.6966 -87.4403 \"seg_025\" 30.064 -86.5374 \"seg_026\" 30.0696 -86.5376 \"seg_027\" 29.9065 -86.0905 \"seg_028\" 30.0532 -87.3661 \"seg_029\" 30.0522 -87.3662 \"seg_030\" 29.8234 -85.7143 \"seg_031\" 29.8234 -85.7143","title":".latitude"},{"location":"PopObj_accessing/#slices","text":"","title":"Slices"},{"location":"PopObj_accessing/#general","text":"You can likewise use slices to access parts of these data. If you're migrating from R or Python, it's the simple bracket accessor you're already familiar with, used to pull out a range of values. Julia just calls them slices. Let's look at a slice of .ind . slice .ind julia > ncats . ind [ 1 : 6 ] output 6-element Array{String,1}: \"N215\" \"N216\" \"N217\" \"N218\" \"N219\" \"N220\" Here's another example: slice .loci julia > ncats . loci [ 3 : end ] output 7-element Array{String,1}: \"fca43\" \"fca45\" \"fca77\" \"fca78\" \"fca90\" \"fca96\" \"fca37\" :end All things start at 1, so there is no need for a special word for it. On the other hand, objects can have unknown lengths or varied lengths as you work with them. In Julia, use the word end in a slice range to indicate you want it to go to the end,, regardless of length or known size.","title":"general"},{"location":"PopObj_accessing/#genotypes_1","text":"We can do this for all the accessors, except genotypes , because it's a dictionary and has slightly different syntax. To use slices on genotypes , you will need to call the locus by name using the Dict syntax, then take a slice of that: slice genotypes julia > ncats . genotypes [ \"fca8\" ][ 1 : 3 ] output 3-element Array{Any,1}: (0, 0) (0, 0) (135, 143)","title":"genotypes"},{"location":"PopObj_accessing/#operating-on-accessors","text":"These accessors follow the exact same format as the dot operator in Python, or the $ operator in R, meaning these objects can be assigned to new variables, you can operate on them, iterate over them, etc. Here's a simple example to display the unique population ID's in your PopObj unique julia > unique ( ncats . popid ) output 17-element Array{Union{Int64, String},1}: \"1\" \"2\" \"3\" \"4\" \"5\" \"6\" \"7\" \"8\" \"9\" \"10\" \"11\" \"12\" \"13\" \"14\" \"15\" \"16\" \"17\" Pipes Julia has native piping (much like BASH) which uses the syntax |> (pipe + greater-than). With a pipe, unique(ncats.popid) can also be rewritten as ncats.popid |> unique for the same result. It's often a matter of preference for which you consider more readable. Use the Pipe package for even more robust piping where you can specify which argument the pipe relates to!","title":"Operating on accessors"},{"location":"PopObj_accessing/#what-to-avoid","text":"Given the relationships of the ordered list of individuals ( .ind ), their population ID's ( .popid ), and the order of genotypes in .genotypes , NEVER USE sort , sort! , or manually arrange/add/delete anything in .ind or popid !!! There are included functions remove_loci! and remove_inds! that do that kind of thing. That being said, you can rename individuals and their popid's without issue. Just no manual moving or deleting! Let's look at what happens when you mananually delete an individual julia> pop!(ncats.ind) \"N290\" Well, that seems benign, it removed the last individual from nancycats... Except it didn't, not fully. There is still a popid associated with that individual, and each of the 9 loci still have a genotype for it. If you had location data, it would still be there too. Now, the lengths of everything is messed up! julia> length(ncats.ind) 236 julia> length(ncats.popid) 237 julia> length(ncats.genotypes[\"fca8\"]) 237 This is obviously a problem, and if you manually delete an individual from somewhere in the middle, then all the popid s and genotypes following it are shifted one, associated with the wrong individual. You would have to manually delete all the traces of this individual, which is annoying. Instead, did that work for you with the remove_ind! command!","title":"\ud83d\uded1\u274c What to avoid! \u274c\ud83d\uded1"},{"location":"commands/","text":"These are the included PopObj viewing and manipulating commands. Using standard Julia conventions, only commands ending with a bang ! are mutable, meaning they alter the input data. This means that a command like popid will show you population ID's, whereas popid! will change them in your PopObj input. To follow along like a tutorial, use the gulfsharks data. Load the data in if you haven't already: julia > using PopGen julia > sharks = gulfsharks () ; individuals view individuals' names indnames ( x :: PopObj ) View individual/sample names in a PopObj . This is equivalent to PopObj.ind indnames indnames ( sharks ) output 212-element Array{String,1}: \"cc_001\" \"cc_002\" \"cc_003\" \"cc_005\" \"cc_007\" \"cc_008\" \"cc_009\" \"cc_010\" \"cc_012\" \"cc_013\" \u22ee \"seg_023\" \"seg_024\" \"seg_025\" \"seg_026\" \"seg_027\" \"seg_028\" \"seg_029\" \"seg_030\" \"seg_031\" remove individuals remove_inds! ( x :: PopObj , inds :: Union { Array { String , 1 }}) Removes selected individuals from a PopObj . Input can be a single individual, or an array of individuals. Will output entire PopObj , so it's better to use a semicolon to suppress the output. Use summary or .ind if you want to confirm that the individuals were removed. This command will inform you if individuals were not found in the data. Examples: single individual julia > remove_inds! ( sharks , \"cc_001\" ) ; julia > summary ( sharks ) single output Object of type PopObj: Longitude: [\"-80.59958\", \"-80.42248\", \"-80.35779\"] \u2026 [\"-87.36617\", \"-85.71432\", \"-85.71432\"] Latitude: [\"28.30624\", \"28.30787\", \"28.30234\"] \u2026 [\"30.05217\", \"29.82344\", \"29.82344\"] Number of individuals: 211 [\"cc_002\", \"cc_003\", \"cc_005\"] \u2026 [\"seg_029\", \"seg_030\", \"seg_031\"] Number of loci: 2213 [\"contig_35208\", \"contig_23109\", \"contig_4493\"] \u2026 [\"contig_19384\", \"contig_22368\", \"contig_2784\"] Ploidy: 2 Number of populations: 7 #Inds | Pop -------------- 20 | 1 30 | 2 28 | 3 65 | 4 28 | 5 20 | 6 20 | 7 Available fields: ind, popid, loci, ploidy, genotypes, longitude, latitude multiple individuals julia > remove_inds! ( sharks , [ \"cc_001\" , \"cc_002\" , \"cc_003\" ]) ; julia > summary ( sharks ) multiple output NOTICE: ind \"cc_001\" not found! Object of type PopObj: Longitude: [\"-80.34815\", \"-80.34822\", \"-80.43027\"] \u2026 [\"-87.36617\", \"-85.71432\", \"-85.71432\"] Latitude: [\"28.30624\", \"28.30787\", \"28.30234\"] \u2026 [\"30.05217\", \"29.82344\", \"29.82344\"] Number of individuals: 209 [\"cc_005\", \"cc_007\", \"cc_008\"] \u2026 [\"seg_029\", \"seg_030\", \"seg_031\"] Number of loci: 2213 [\"contig_35208\", \"contig_23109\", \"contig_4493\"] \u2026 [\"contig_19384\", \"contig_22368\", \"contig_2784\"] Ploidy: 2 Number of populations: 7 #Inds | Pop -------------- 18 | 1 30 | 2 28 | 3 65 | 4 28 | 5 20 | 6 20 | 7 Available fields: ind, popid, loci, ploidy, genotypes, longitude, latitude ind not found! If removing a single individual and it is not found in the PopObj, an error will be returned. However, if removing multiple individuals, you will receive a notice above the PopObj summary indicating which individuals were not found, while removing the ones that were. population ID's view population names popid ( x :: PopObj ; listall :: Bool = false ) Just as you can view population ID's with .popid , you can also view them with the popid() command, which by default shows you a summary of the number of individuals in each population, just like you see when using summary . The #Inds means \"number of individuals\", and Pop refers to the population names. popid julia > popid ( sharks ) output #Inds | Pop -------------- 21 | 1 30 | 2 28 | 3 65 | 4 28 | 5 20 | 6 20 | 7 You can use the keyword listall=true to display each individual and their associated population as a DataFrame. You'll notice the DataFrame looks remarkably like the first two columns of the one from locations , and it sort of is. Unlike locations , this will not give you an error when location data is missing. listall=true julia > popid ( sharks , listall = true ) output 212\u00d72 DataFrames.DataFrame \u2502 Row \u2502 ind \u2502 population \u2502 \u2502 \u2502 String \u2502 Union\u2026 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 cc_001 \u2502 1 \u2502 \u2502 2 \u2502 cc_002 \u2502 1 \u2502 \u2502 3 \u2502 cc_003 \u2502 1 \u2502 \u2502 4 \u2502 cc_005 \u2502 1 \u2502 \u2502 5 \u2502 cc_007 \u2502 1 \u2502 \u2502 6 \u2502 cc_008 \u2502 1 \u2502 \u2502 7 \u2502 cc_009 \u2502 1 \u2502 \u22ee \u2502 205 \u2502 seg_024 \u2502 7 \u2502 \u2502 206 \u2502 seg_025 \u2502 7 \u2502 \u2502 207 \u2502 seg_026 \u2502 7 \u2502 \u2502 208 \u2502 seg_027 \u2502 7 \u2502 \u2502 209 \u2502 seg_028 \u2502 7 \u2502 \u2502 210 \u2502 seg_029 \u2502 7 \u2502 \u2502 211 \u2502 seg_030 \u2502 7 \u2502 \u2502 212 \u2502 seg_031 \u2502 7 \u2502 rename populations popid! ( x :: PopObj ; rename :: Dict ) Rename the population ID's of a PopObj (the .popid ). Uses a Dict of [popid] => replacement to rename. It returns popid(::PopObj,listall=true) of your renamed PopObj. rename populations # create a dictionary of name conversions julia > new_popnames = Dict ( 1 => \"Cape Canaveral\" , 2 => \"Georgia\" , 3 => \"S Carolina\" , 4 => \"FL Keys\" , 5 => \"Mideast Gulf\" , 6 => \"Northeast Gulf\" , 7 => \"Southeast Gulf\" ) julia > popid! ( sharks , rename = new_popnames ) output 212\u00d72 DataFrame \u2502 Row \u2502 ind \u2502 population \u2502 \u2502 \u2502 String \u2502 Union\u2026 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 cc_001 \u2502 Cape Canaveral \u2502 \u2502 2 \u2502 cc_002 \u2502 Cape Canaveral \u2502 \u2502 3 \u2502 cc_003 \u2502 Cape Canaveral \u2502 \u2502 4 \u2502 cc_005 \u2502 Cape Canaveral \u2502 \u2502 5 \u2502 cc_007 \u2502 Cape Canaveral \u2502 \u2502 6 \u2502 cc_008 \u2502 Cape Canaveral \u2502 \u2502 7 \u2502 cc_009 \u2502 Cape Canaveral \u2502 \u2502 8 \u2502 cc_010 \u2502 Cape Canaveral \u2502 \u2502 9 \u2502 cc_012 \u2502 Cape Canaveral \u2502 \u2502 10 \u2502 cc_013 \u2502 Cape Canaveral \u2502 \u2502 11 \u2502 cc_014 \u2502 Cape Canaveral \u2502 \u2502 12 \u2502 cc_015 \u2502 Cape Canaveral \u2502 \u2502 13 \u2502 cc_016 \u2502 Cape Canaveral \u2502 \u2502 14 \u2502 cc_017 \u2502 Cape Canaveral \u2502 \u2502 15 \u2502 cc_018 \u2502 Cape Canaveral \u2502 \u2502 16 \u2502 cc_019 \u2502 Cape Canaveral \u2502 \u2502 17 \u2502 cc_020 \u2502 Cape Canaveral \u2502 \u2502 18 \u2502 cc_021 \u2502 Cape Canaveral \u2502 \u22ee \u2502 194 \u2502 seg_003 \u2502 Southeast Gulf \u2502 \u2502 195 \u2502 seg_009 \u2502 Southeast Gulf \u2502 \u2502 196 \u2502 seg_010 \u2502 Southeast Gulf \u2502 \u2502 197 \u2502 seg_011 \u2502 Southeast Gulf \u2502 \u2502 198 \u2502 seg_012 \u2502 Southeast Gulf \u2502 \u2502 199 \u2502 seg_014 \u2502 Southeast Gulf \u2502 \u2502 200 \u2502 seg_015 \u2502 Southeast Gulf \u2502 \u2502 201 \u2502 seg_016 \u2502 Southeast Gulf \u2502 \u2502 202 \u2502 seg_018 \u2502 Southeast Gulf \u2502 \u2502 203 \u2502 seg_021 \u2502 Southeast Gulf \u2502 \u2502 204 \u2502 seg_023 \u2502 Southeast Gulf \u2502 \u2502 205 \u2502 seg_024 \u2502 Southeast Gulf \u2502 \u2502 206 \u2502 seg_025 \u2502 Southeast Gulf \u2502 \u2502 207 \u2502 seg_026 \u2502 Southeast Gulf \u2502 \u2502 208 \u2502 seg_027 \u2502 Southeast Gulf \u2502 \u2502 209 \u2502 seg_028 \u2502 Southeast Gulf \u2502 \u2502 210 \u2502 seg_029 \u2502 Southeast Gulf \u2502 \u2502 211 \u2502 seg_030 \u2502 Southeast Gulf \u2502 \u2502 212 \u2502 seg_031 \u2502 Southeast Gulf \u2502 genotypes per locus view loci loci ( x :: PopObj , loci = nothing ) View the genotypes of all individuals for specific loci in a PopObj . Default shows all genotypes for all individuals. Returns a DataFrame. all loci julia > loci ( sharks ) output 212\u00d72215 DataFrames.DataFrame. Omitted printing of 2209 columns \u2502 Row \u2502 ind \u2502 population \u2502 contig_10001 \u2502 contig_10013 \u2502 contig_10028 \u2502 contig_10035 \u2502 \u2502 \u2502 String \u2502 Categorical\u2026 \u2502 Any \u2502 Any \u2502 Any \u2502 Any \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 cc_001 \u2502 1 \u2502 (1, 1) \u2502 (1, 1) \u2502 (1, 1) \u2502 (1, 1) \u2502 \u2502 2 \u2502 cc_002 \u2502 1 \u2502 (1, 1) \u2502 (1, 1) \u2502 (1, 1) \u2502 (1, 1) \u2502 \u2502 3 \u2502 cc_003 \u2502 1 \u2502 (1, 1) \u2502 (1, 1) \u2502 (2, 1) \u2502 (1, 1) \u2502 \u2502 4 \u2502 cc_005 \u2502 1 \u2502 (1, 1) \u2502 (1, 1) \u2502 (1, 1) \u2502 (2, 1) \u2502 \u2502 5 \u2502 cc_007 \u2502 1 \u2502 (1, 1) \u2502 (1, 1) \u2502 (2, 1) \u2502 (2, 1) \u2502 \u2502 6 \u2502 cc_008 \u2502 1 \u2502 (1, 1) \u2502 (1, 2) \u2502 (2, 1) \u2502 (1, 1) \u2502 \u2502 7 \u2502 cc_009 \u2502 1 \u2502 (1, 1) \u2502 (1, 2) \u2502 (2, 1) \u2502 (2, 1) \u2502 \u22ee \u2502 205 \u2502 seg_024 \u2502 7 \u2502 (1, 1) \u2502 (1, 1) \u2502 (1, 1) \u2502 (1, 1) \u2502 \u2502 206 \u2502 seg_025 \u2502 7 \u2502 (1, 1) \u2502 (1, 1) \u2502 (2, 1) \u2502 (2, 2) \u2502 \u2502 207 \u2502 seg_026 \u2502 7 \u2502 (1, 1) \u2502 (1, 1) \u2502 (2, 1) \u2502 (2, 2) \u2502 \u2502 208 \u2502 seg_027 \u2502 7 \u2502 (1, 1) \u2502 (1, 1) \u2502 (1, 1) \u2502 (2, 2) \u2502 \u2502 209 \u2502 seg_028 \u2502 7 \u2502 (1, 1) \u2502 (1, 1) \u2502 (2, 1) \u2502 (2, 2) \u2502 \u2502 210 \u2502 seg_029 \u2502 7 \u2502 (1, 1) \u2502 (1, 1) \u2502 (2, 1) \u2502 (2, 2) \u2502 \u2502 211 \u2502 seg_030 \u2502 7 \u2502 (1, 1) \u2502 (1, 1) \u2502 (2, 1) \u2502 (2, 2) \u2502 \u2502 212 \u2502 seg_031 \u2502 7 \u2502 (1, 1) \u2502 (1, 1) \u2502 (1, 1) \u2502 (1, 1) \u2502 Add a second argument (no keywords!) to specify a single locus (string) or multiple loci (array of strings) to display single locus julia > loci ( sharks , \"contig_10001\" ) single output 212\u00d73 DataFrames.DataFrame \u2502 Row \u2502 ind \u2502 population \u2502 contig_10001 \u2502 \u2502 \u2502 String \u2502 Categorical\u2026 \u2502 Any \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 cc_001 \u2502 1 \u2502 (1, 1) \u2502 \u2502 2 \u2502 cc_002 \u2502 1 \u2502 (1, 1) \u2502 \u2502 3 \u2502 cc_003 \u2502 1 \u2502 (1, 1) \u2502 \u2502 4 \u2502 cc_005 \u2502 1 \u2502 (1, 1) \u2502 \u2502 5 \u2502 cc_007 \u2502 1 \u2502 (1, 1) \u2502 \u2502 6 \u2502 cc_008 \u2502 1 \u2502 (1, 1) \u2502 \u2502 7 \u2502 cc_009 \u2502 1 \u2502 (1, 1) \u2502 \u22ee \u2502 205 \u2502 seg_024 \u2502 7 \u2502 (1, 1) \u2502 \u2502 206 \u2502 seg_025 \u2502 7 \u2502 (1, 1) \u2502 \u2502 207 \u2502 seg_026 \u2502 7 \u2502 (1, 1) \u2502 \u2502 208 \u2502 seg_027 \u2502 7 \u2502 (1, 1) \u2502 \u2502 209 \u2502 seg_028 \u2502 7 \u2502 (1, 1) \u2502 \u2502 210 \u2502 seg_029 \u2502 7 \u2502 (1, 1) \u2502 \u2502 211 \u2502 seg_030 \u2502 7 \u2502 (1, 1) \u2502 \u2502 212 \u2502 seg_031 \u2502 7 \u2502 (1, 1) \u2502 multiple loci julia > loci ( sharks , [ \"contig_10001\" , \"contig_10028\" ]) multiple output 212\u00d74 DataFrames.DataFrame \u2502 Row \u2502 ind \u2502 population \u2502 contig_10001 \u2502 contig_10028 \u2502 \u2502 \u2502 String \u2502 Categorical\u2026 \u2502 Any \u2502 Any \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 cc_001 \u2502 1 \u2502 (1, 1) \u2502 (1, 1) \u2502 \u2502 2 \u2502 cc_002 \u2502 1 \u2502 (1, 1) \u2502 (1, 1) \u2502 \u2502 3 \u2502 cc_003 \u2502 1 \u2502 (1, 1) \u2502 (2, 1) \u2502 \u2502 4 \u2502 cc_005 \u2502 1 \u2502 (1, 1) \u2502 (1, 1) \u2502 \u2502 5 \u2502 cc_007 \u2502 1 \u2502 (1, 1) \u2502 (2, 1) \u2502 \u2502 6 \u2502 cc_008 \u2502 1 \u2502 (1, 1) \u2502 (2, 1) \u2502 \u2502 7 \u2502 cc_009 \u2502 1 \u2502 (1, 1) \u2502 (2, 1) \u2502 \u22ee \u2502 205 \u2502 seg_024 \u2502 7 \u2502 (1, 1) \u2502 (1, 1) \u2502 \u2502 206 \u2502 seg_025 \u2502 7 \u2502 (1, 1) \u2502 (2, 1) \u2502 \u2502 207 \u2502 seg_026 \u2502 7 \u2502 (1, 1) \u2502 (2, 1) \u2502 \u2502 208 \u2502 seg_027 \u2502 7 \u2502 (1, 1) \u2502 (1, 1) \u2502 \u2502 209 \u2502 seg_028 \u2502 7 \u2502 (1, 1) \u2502 (2, 1) \u2502 \u2502 210 \u2502 seg_029 \u2502 7 \u2502 (1, 1) \u2502 (2, 1) \u2502 \u2502 211 \u2502 seg_030 \u2502 7 \u2502 (1, 1) \u2502 (2, 1) \u2502 \u2502 212 \u2502 seg_031 \u2502 7 \u2502 (1, 1) \u2502 (1, 1) \u2502 remove loci remove_loci! ( x :: PopObj , loci :: Union { String , Array { String , 1 }}) Removes selected loci from a PopObj . Input can be a single locus, or an array of loci. Examples: single locus julia > remove_loci! ( sharks , \"contig_35208\" ) ; julia > summary ( sharks ) single output Object of type PopObj: Longitude: [\"-80.59928\", \"-80.59954\", \"-80.59958\"] \u2026 [\"-87.36617\", \"-85.71432\", \"-85.71432\"] Latitude: [\"28.30624\", \"28.30787\", \"28.30234\"] \u2026 [\"30.05217\", \"29.82344\", \"29.82344\"] Number of individuals: 212 [\"cc_001\", \"cc_002\", \"cc_003\"] \u2026 [\"seg_029\", \"seg_030\", \"seg_031\"] Number of loci: 2212 [\"contig_23109\", \"contig_4493\", \"contig_10742\"] \u2026 [\"contig_19384\", \"contig_22368\", \"contig_2784\"] Ploidy: 2 Number of populations: 7 #Inds | Pop -------------- 21 | 1 30 | 2 28 | 3 65 | 4 28 | 5 20 | 6 20 | 7 Available fields: ind, popid, loci, ploidy, genotypes, longitude, latitude multiple loci julia > remove_loci! ( sharks , [ \"contig_35208\" , \"contig_23109\" , \"contig_4493\" ]) ; julia > summary ( sharks ) multiple output NOTICE: locus \"contig_35208\" not found Object of type PopObj: Longitude: [\"-80.59928\", \"-80.59954\", \"-80.59958\"] \u2026 [\"-87.36617\", \"-85.71432\", \"-85.71432\"] Latitude: [\"28.30624\", \"28.30787\", \"28.30234\"] \u2026 [\"30.05217\", \"29.82344\", \"29.82344\"] Number of individuals: 212 [\"cc_001\", \"cc_002\", \"cc_003\"] \u2026 [\"seg_029\", \"seg_030\", \"seg_031\"] Number of loci: 2210 [\"contig_10742\", \"contig_14898\", \"contig_8483\"] \u2026 [\"contig_19384\", \"contig_22368\", \"contig_2784\"] Ploidy: 2 Number of populations: 7 #Inds | Pop -------------- 21 | 1 30 | 2 28 | 3 65 | 4 28 | 5 20 | 6 20 | 7 Available fields: ind, popid, loci, ploidy, genotypes, longitude, latitude locus not found! If removing a single locus and it is not found in the PopObj, an error will be returned. However, if removing multiple loci, you will receive a notice above the PopObj summary indicating which loci were not found, while removing the ones that were. genotypes per individual view specific genotypes Sometimes you want/need to view genotypes of specific individuals, and that's what genotypes is for. By default, the command will show you a DataFrame of the genotypes of all individuals for all loci. genotypes julia > genotypes ( sharks ) output 212\u00d72215 DataFrames.DataFrame. Omitted printing of 2209 columns \u2502 Row \u2502 ind \u2502 population \u2502 contig_10001 \u2502 contig_10013 \u2502 contig_10028 \u2502 contig_10035 \u2502 \u2502 \u2502 String \u2502 Categorical\u2026 \u2502 Any \u2502 Any \u2502 Any \u2502 Any \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 cc_001 \u2502 1 \u2502 (1, 1) \u2502 (1, 1) \u2502 (1, 1) \u2502 (1, 1) \u2502 \u2502 2 \u2502 cc_002 \u2502 1 \u2502 (1, 1) \u2502 (1, 1) \u2502 (1, 1) \u2502 (1, 1) \u2502 \u2502 3 \u2502 cc_003 \u2502 1 \u2502 (1, 1) \u2502 (1, 1) \u2502 (2, 1) \u2502 (1, 1) \u2502 \u2502 4 \u2502 cc_005 \u2502 1 \u2502 (1, 1) \u2502 (1, 1) \u2502 (1, 1) \u2502 (2, 1) \u2502 \u2502 5 \u2502 cc_007 \u2502 1 \u2502 (1, 1) \u2502 (1, 1) \u2502 (2, 1) \u2502 (2, 1) \u2502 \u2502 6 \u2502 cc_008 \u2502 1 \u2502 (1, 1) \u2502 (1, 2) \u2502 (2, 1) \u2502 (1, 1) \u2502 \u2502 7 \u2502 cc_009 \u2502 1 \u2502 (1, 1) \u2502 (1, 2) \u2502 (2, 1) \u2502 (2, 1) \u2502 \u22ee \u2502 205 \u2502 seg_024 \u2502 7 \u2502 (1, 1) \u2502 (1, 1) \u2502 (1, 1) \u2502 (1, 1) \u2502 \u2502 206 \u2502 seg_025 \u2502 7 \u2502 (1, 1) \u2502 (1, 1) \u2502 (2, 1) \u2502 (2, 2) \u2502 \u2502 207 \u2502 seg_026 \u2502 7 \u2502 (1, 1) \u2502 (1, 1) \u2502 (2, 1) \u2502 (2, 2) \u2502 \u2502 208 \u2502 seg_027 \u2502 7 \u2502 (1, 1) \u2502 (1, 1) \u2502 (1, 1) \u2502 (2, 2) \u2502 \u2502 209 \u2502 seg_028 \u2502 7 \u2502 (1, 1) \u2502 (1, 1) \u2502 (2, 1) \u2502 (2, 2) \u2502 \u2502 210 \u2502 seg_029 \u2502 7 \u2502 (1, 1) \u2502 (1, 1) \u2502 (2, 1) \u2502 (2, 2) \u2502 \u2502 211 \u2502 seg_030 \u2502 7 \u2502 (1, 1) \u2502 (1, 1) \u2502 (2, 1) \u2502 (2, 2) \u2502 \u2502 212 \u2502 seg_031 \u2502 7 \u2502 (1, 1) \u2502 (1, 1) \u2502 (1, 1) \u2502 (1, 1) \u2502 Using the inds = keyword argument, you can specify a single individual (string) or multiple individuals (array of strings) to view only a subset single genotypes julia > genotypes ( sharks , inds = \"key_037\" ) single output 1\u00d72215 DataFrames.DataFrame. Omitted printing of 2209 columns \u2502 Row \u2502 ind \u2502 population \u2502 contig_10001 \u2502 contig_10013 \u2502 contig_10028 \u2502 contig_10035 \u2502 \u2502 \u2502 String \u2502 Categorical\u2026 \u2502 Any \u2502 Any \u2502 Any \u2502 Any \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 key_037 \u2502 4 \u2502 (1, 1) \u2502 (1, 1) \u2502 (2, 1) \u2502 (2, 1) \u2502 multiple genotypes julia > genotypes ( sharks , inds = [ \"cc_008\" , \"meg_015\" ]) multiple output 2\u00d72215 DataFrames.DataFrame. Omitted printing of 2209 columns \u2502 Row \u2502 ind \u2502 population \u2502 contig_10001 \u2502 contig_10013 \u2502 contig_10028 \u2502 contig_10035 \u2502 \u2502 \u2502 String \u2502 Categorical\u2026 \u2502 Any \u2502 Any \u2502 Any \u2502 Any \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 cc_008 \u2502 1 \u2502 (1, 1) \u2502 (1, 2) \u2502 (2, 1) \u2502 (1, 1) \u2502 \u2502 2 \u2502 meg_015 \u2502 5 \u2502 (1, 1) \u2502 (1, 1) \u2502 (1, 1) \u2502 (2, 2) \u2502 Info Since many of the outputs of these functions are in DataFrame format, you have the flexibility to use the tools in DataFrames.jl as well as Query.jl to filter and subset these data even further. missing data view missing data Used to show missingness information-- that is, loci missing allele information. This command outputs two DataFrames, the first being a count of number of missing loci per individual, the other being the number of times a locus is missing across individuals. missing julia > missing ( sharks ) output (212\u00d74 DataFrames.DataFrame. Omitted printing of 1 columns \u2502 Row \u2502 ind \u2502 population \u2502 nmissing \u2502 \u2502 \u2502 String \u2502 String \u2502 Any \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 cc_001 \u2502 1 \u2502 124 \u2502 \u2502 2 \u2502 cc_002 \u2502 1 \u2502 94 \u2502 \u2502 3 \u2502 cc_003 \u2502 1 \u2502 100 \u2502 \u2502 4 \u2502 cc_005 \u2502 1 \u2502 0 \u2502 \u2502 5 \u2502 cc_007 \u2502 1 \u2502 2 \u2502 \u2502 6 \u2502 cc_008 \u2502 1 \u2502 1 \u2502 \u2502 7 \u2502 cc_009 \u2502 1 \u2502 2 \u2502 \u22ee \u2502 205 \u2502 seg_024 \u2502 7 \u2502 0 \u2502 \u2502 206 \u2502 seg_025 \u2502 7 \u2502 0 \u2502 \u2502 207 \u2502 seg_026 \u2502 7 \u2502 0 \u2502 \u2502 208 \u2502 seg_027 \u2502 7 \u2502 2 \u2502 \u2502 209 \u2502 seg_028 \u2502 7 \u2502 25 \u2502 \u2502 210 \u2502 seg_029 \u2502 7 \u2502 0 \u2502 \u2502 211 \u2502 seg_030 \u2502 7 \u2502 1 \u2502 \u2502 212 \u2502 seg_031 \u2502 7 \u2502 1 \u2502, 2213\u00d72 DataFrames.DataFrame \u2502 Row \u2502 locus \u2502 nmissing \u2502 \u2502 \u2502 String \u2502 Any \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 contig_35208 \u2502 0 \u2502 \u2502 2 \u2502 contig_23109 \u2502 6 \u2502 \u2502 3 \u2502 contig_4493 \u2502 3 \u2502 \u2502 4 \u2502 contig_10742 \u2502 2 \u2502 \u2502 5 \u2502 contig_14898 \u2502 0 \u2502 \u2502 6 \u2502 contig_8483 \u2502 0 \u2502 \u2502 7 \u2502 contig_8065 \u2502 0 \u2502 \u22ee \u2502 2206 \u2502 contig_24711 \u2502 0 \u2502 \u2502 2207 \u2502 contig_18959 \u2502 0 \u2502 \u2502 2208 \u2502 contig_43517 \u2502 6 \u2502 \u2502 2209 \u2502 contig_27356 \u2502 2 \u2502 \u2502 2210 \u2502 contig_475 \u2502 0 \u2502 \u2502 2211 \u2502 contig_19384 \u2502 5 \u2502 \u2502 2212 \u2502 contig_22368 \u2502 3 \u2502 \u2502 2213 \u2502 contig_2784 \u2502 7 \u2502) Since missing outputs a tuple of dataframes, an easier way to use this function is with multiple assignment: missing julia > df1 , df2 = missing ( sharks ) ; df1 julia> df1 212\u00d74 DataFrames.DataFrame. Omitted printing of 1 columns \u2502 Row \u2502 ind \u2502 population \u2502 nmissing \u2502 \u2502 \u2502 String \u2502 String \u2502 Any \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 cc_001 \u2502 1 \u2502 124 \u2502 \u2502 2 \u2502 cc_002 \u2502 1 \u2502 94 \u2502 \u2502 3 \u2502 cc_003 \u2502 1 \u2502 100 \u2502 \u2502 4 \u2502 cc_005 \u2502 1 \u2502 0 \u2502 \u2502 5 \u2502 cc_007 \u2502 1 \u2502 2 \u2502 \u2502 6 \u2502 cc_008 \u2502 1 \u2502 1 \u2502 \u2502 7 \u2502 cc_009 \u2502 1 \u2502 2 \u2502 \u22ee \u2502 205 \u2502 seg_024 \u2502 7 \u2502 0 \u2502 \u2502 206 \u2502 seg_025 \u2502 7 \u2502 0 \u2502 \u2502 207 \u2502 seg_026 \u2502 7 \u2502 0 \u2502 \u2502 208 \u2502 seg_027 \u2502 7 \u2502 2 \u2502 \u2502 209 \u2502 seg_028 \u2502 7 \u2502 25 \u2502 \u2502 210 \u2502 seg_029 \u2502 7 \u2502 0 \u2502 \u2502 211 \u2502 seg_030 \u2502 7 \u2502 1 \u2502 \u2502 212 \u2502 seg_031 \u2502 7 \u2502 1 \u2502 df2 julia> df2 2213\u00d72 DataFrames.DataFrame \u2502 Row \u2502 locus \u2502 nmissing \u2502 \u2502 \u2502 String \u2502 Any \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 contig_35208 \u2502 0 \u2502 \u2502 2 \u2502 contig_23109 \u2502 6 \u2502 \u2502 3 \u2502 contig_4493 \u2502 3 \u2502 \u2502 4 \u2502 contig_10742 \u2502 2 \u2502 \u2502 5 \u2502 contig_14898 \u2502 0 \u2502 \u2502 6 \u2502 contig_8483 \u2502 0 \u2502 \u2502 7 \u2502 contig_8065 \u2502 0 \u2502 \u22ee \u2502 2206 \u2502 contig_24711 \u2502 0 \u2502 \u2502 2207 \u2502 contig_18959 \u2502 0 \u2502 \u2502 2208 \u2502 contig_43517 \u2502 6 \u2502 \u2502 2209 \u2502 contig_27356 \u2502 2 \u2502 \u2502 2210 \u2502 contig_475 \u2502 0 \u2502 \u2502 2211 \u2502 contig_19384 \u2502 5 \u2502 \u2502 2212 \u2502 contig_22368 \u2502 3 \u2502 \u2502 2213 \u2502 contig_2784 \u2502 7 \u2502 Info Python has this feature, however, if you're migrating from R, multiple assignment probably looks weird, or like flat-out sorcery. Whenever a function returns a tuple of values, like missing does, you can assign as many variables to it at once. For example: a , b , c , d = ( 1 , 2 , 3 ,[ 4 , 5 , 6 , 7 ]) where a = 1 b = 2 c = 3 d = [4, 5, 6, 7] embrace the convenience! plot missing data plot_missing ( x :: PopObj ; color = false ) Return an interactive plot of the number of missing loci in individuals of a PopObj , along with the number of missing individuals per locus. Use color = [color1, color2, ...] to set a custom color palette for the boxplots. Example: julia > plot_missing ( sharks ) saving interactive plots To save the interactive plots, you can use the savehtml function from the PlotlyJS.jl package: PlotlyJS . savehtml ( plot , \"filename.html\" ) If you don't specify a full path in the filename, it will save it in your current working directory. #example julia > using PlotlyJS ; julia > PlotlyJS . savehtml ( plot_missing ( sharks ), \"/home/pdimens/missingness.html\" ) use a third argument :embed to make the plots fully viewable offline. The output files are much larger (relatively) because it embeds the Plotly javeascript into the file. For context, the gulfsharks plot file is ~3.5mb when using :embed \u200b \u200b location data view location data locations ( x :: PopObj ) View location data ( .longitude and .latitude ) in a PopObj If you want to do your own plotting, or just to look at the spatial data of your PopObj, this function is handy. It takes no additional arguments and outputs a DataFrame of individual names, population ID's, and their latitude/longitude information. locations julia > locations ( sharks ) output 212\u00d74 DataFrames.DataFrame \u2502 Row \u2502 ind \u2502 population \u2502 longitude \u2502 latitude \u2502 \u2502 \u2502 String \u2502 Union\u2026 \u2502 Union\u2026 \u2502 Union\u2026 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 cc_001 \u2502 1 \u2502 -80.5993 \u2502 28.3062 \u2502 \u2502 2 \u2502 cc_002 \u2502 1 \u2502 -80.5995 \u2502 28.3079 \u2502 \u2502 3 \u2502 cc_003 \u2502 1 \u2502 -80.5996 \u2502 28.3023 \u2502 \u2502 4 \u2502 cc_005 \u2502 1 \u2502 -80.4225 \u2502 28.6123 \u2502 \u2502 5 \u2502 cc_007 \u2502 1 \u2502 -80.3578 \u2502 27.8666 \u2502 \u2502 6 \u2502 cc_008 \u2502 1 \u2502 -80.3579 \u2502 27.8666 \u2502 \u2502 7 \u2502 cc_009 \u2502 1 \u2502 -80.3482 \u2502 27.8682 \u2502 \u22ee \u2502 205 \u2502 seg_024 \u2502 7 \u2502 -87.4403 \u2502 29.6966 \u2502 \u2502 206 \u2502 seg_025 \u2502 7 \u2502 -86.5374 \u2502 30.064 \u2502 \u2502 207 \u2502 seg_026 \u2502 7 \u2502 -86.5376 \u2502 30.0696 \u2502 \u2502 208 \u2502 seg_027 \u2502 7 \u2502 -86.0905 \u2502 29.9065 \u2502 \u2502 209 \u2502 seg_028 \u2502 7 \u2502 -87.3661 \u2502 30.0532 \u2502 \u2502 210 \u2502 seg_029 \u2502 7 \u2502 -87.3662 \u2502 30.0522 \u2502 \u2502 211 \u2502 seg_030 \u2502 7 \u2502 -85.7143 \u2502 29.8234 \u2502 \u2502 212 \u2502 seg_031 \u2502 7 \u2502 -85.7143 \u2502 29.8234 \u2502 locations secondary feature There is a built-in component in locations to test if the location data 1) exists, and 2) is of equal length, or it will spit out an error. It's probably a good idea to do this for your data at least once to be assured everything is ok! add location data Location data can be added by directly accessing the fields .longitude and .latitude in your PopObj , such as this example: julia > sharks . longitude = rand ( 1 : 50 , 212 ) ; # creates 212 unique random numbers between 1 and 50 julia > sharks . latitdue = rand ( 20 : 30 , 212 ) ; # creates 212 unique random numbers between 20 and 30 However, if your data is in decimal minutes rather than decimal degrees, use the locations! function to add it to the fields. This function will do a conversion from decimal minutes to decimal degrees for you. To import those data into Julia, you'll likely want to use the wonderful CSV.jl package first. decimal minutes data locations! ( x :: PopObj ; xloc :: Array , yloc :: Array ) Adds location data (longitude, latitude) to PopObj . Takes decimal degrees or decimal minutes format. Must use minus-sign instead of cardinal directions (i.e. 14 32.11W is not vaild). Location data must be in order of individuals ( ind ). Replaces existing PopObj location data. Decimal Degrees : -11.431 Decimal Minutes : \"-11 43.11\" (must use space and double-quotes) If conversion is not necessary, can directly assign PopObj.longitude and PopObj.latitude as shown above. If you still wanted to use locations! but don't need a conversion, it still works: julia > long = a . longitude = rand ( 1 : 50 , 212 ) ; julia > lat = a . latitdue = rand ( 20 : 30 , 212 ) ; julia > locations! ( a , long , lat ) ; plot location data You're encouraged to plot locations however you think is best. For convenience and speed, we provide a plot_locations command to make a decent, albeit simple interactive plot (Plotly) and save some time. Have a look at the command in more detail under \"Functions\" for some configuration options. julia > plot_locations ( sharks )","title":"View/edit PopObj"},{"location":"commands/#individuals","text":"","title":"individuals"},{"location":"commands/#view-individuals-names","text":"indnames ( x :: PopObj ) View individual/sample names in a PopObj . This is equivalent to PopObj.ind indnames indnames ( sharks ) output 212-element Array{String,1}: \"cc_001\" \"cc_002\" \"cc_003\" \"cc_005\" \"cc_007\" \"cc_008\" \"cc_009\" \"cc_010\" \"cc_012\" \"cc_013\" \u22ee \"seg_023\" \"seg_024\" \"seg_025\" \"seg_026\" \"seg_027\" \"seg_028\" \"seg_029\" \"seg_030\" \"seg_031\"","title":"view individuals' names"},{"location":"commands/#remove-individuals","text":"remove_inds! ( x :: PopObj , inds :: Union { Array { String , 1 }}) Removes selected individuals from a PopObj . Input can be a single individual, or an array of individuals. Will output entire PopObj , so it's better to use a semicolon to suppress the output. Use summary or .ind if you want to confirm that the individuals were removed. This command will inform you if individuals were not found in the data. Examples: single individual julia > remove_inds! ( sharks , \"cc_001\" ) ; julia > summary ( sharks ) single output Object of type PopObj: Longitude: [\"-80.59958\", \"-80.42248\", \"-80.35779\"] \u2026 [\"-87.36617\", \"-85.71432\", \"-85.71432\"] Latitude: [\"28.30624\", \"28.30787\", \"28.30234\"] \u2026 [\"30.05217\", \"29.82344\", \"29.82344\"] Number of individuals: 211 [\"cc_002\", \"cc_003\", \"cc_005\"] \u2026 [\"seg_029\", \"seg_030\", \"seg_031\"] Number of loci: 2213 [\"contig_35208\", \"contig_23109\", \"contig_4493\"] \u2026 [\"contig_19384\", \"contig_22368\", \"contig_2784\"] Ploidy: 2 Number of populations: 7 #Inds | Pop -------------- 20 | 1 30 | 2 28 | 3 65 | 4 28 | 5 20 | 6 20 | 7 Available fields: ind, popid, loci, ploidy, genotypes, longitude, latitude multiple individuals julia > remove_inds! ( sharks , [ \"cc_001\" , \"cc_002\" , \"cc_003\" ]) ; julia > summary ( sharks ) multiple output NOTICE: ind \"cc_001\" not found! Object of type PopObj: Longitude: [\"-80.34815\", \"-80.34822\", \"-80.43027\"] \u2026 [\"-87.36617\", \"-85.71432\", \"-85.71432\"] Latitude: [\"28.30624\", \"28.30787\", \"28.30234\"] \u2026 [\"30.05217\", \"29.82344\", \"29.82344\"] Number of individuals: 209 [\"cc_005\", \"cc_007\", \"cc_008\"] \u2026 [\"seg_029\", \"seg_030\", \"seg_031\"] Number of loci: 2213 [\"contig_35208\", \"contig_23109\", \"contig_4493\"] \u2026 [\"contig_19384\", \"contig_22368\", \"contig_2784\"] Ploidy: 2 Number of populations: 7 #Inds | Pop -------------- 18 | 1 30 | 2 28 | 3 65 | 4 28 | 5 20 | 6 20 | 7 Available fields: ind, popid, loci, ploidy, genotypes, longitude, latitude ind not found! If removing a single individual and it is not found in the PopObj, an error will be returned. However, if removing multiple individuals, you will receive a notice above the PopObj summary indicating which individuals were not found, while removing the ones that were.","title":"remove individuals"},{"location":"commands/#population-ids","text":"","title":"population ID's"},{"location":"commands/#view-population-names","text":"popid ( x :: PopObj ; listall :: Bool = false ) Just as you can view population ID's with .popid , you can also view them with the popid() command, which by default shows you a summary of the number of individuals in each population, just like you see when using summary . The #Inds means \"number of individuals\", and Pop refers to the population names. popid julia > popid ( sharks ) output #Inds | Pop -------------- 21 | 1 30 | 2 28 | 3 65 | 4 28 | 5 20 | 6 20 | 7 You can use the keyword listall=true to display each individual and their associated population as a DataFrame. You'll notice the DataFrame looks remarkably like the first two columns of the one from locations , and it sort of is. Unlike locations , this will not give you an error when location data is missing. listall=true julia > popid ( sharks , listall = true ) output 212\u00d72 DataFrames.DataFrame \u2502 Row \u2502 ind \u2502 population \u2502 \u2502 \u2502 String \u2502 Union\u2026 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 cc_001 \u2502 1 \u2502 \u2502 2 \u2502 cc_002 \u2502 1 \u2502 \u2502 3 \u2502 cc_003 \u2502 1 \u2502 \u2502 4 \u2502 cc_005 \u2502 1 \u2502 \u2502 5 \u2502 cc_007 \u2502 1 \u2502 \u2502 6 \u2502 cc_008 \u2502 1 \u2502 \u2502 7 \u2502 cc_009 \u2502 1 \u2502 \u22ee \u2502 205 \u2502 seg_024 \u2502 7 \u2502 \u2502 206 \u2502 seg_025 \u2502 7 \u2502 \u2502 207 \u2502 seg_026 \u2502 7 \u2502 \u2502 208 \u2502 seg_027 \u2502 7 \u2502 \u2502 209 \u2502 seg_028 \u2502 7 \u2502 \u2502 210 \u2502 seg_029 \u2502 7 \u2502 \u2502 211 \u2502 seg_030 \u2502 7 \u2502 \u2502 212 \u2502 seg_031 \u2502 7 \u2502","title":"view population names"},{"location":"commands/#rename-populations","text":"popid! ( x :: PopObj ; rename :: Dict ) Rename the population ID's of a PopObj (the .popid ). Uses a Dict of [popid] => replacement to rename. It returns popid(::PopObj,listall=true) of your renamed PopObj. rename populations # create a dictionary of name conversions julia > new_popnames = Dict ( 1 => \"Cape Canaveral\" , 2 => \"Georgia\" , 3 => \"S Carolina\" , 4 => \"FL Keys\" , 5 => \"Mideast Gulf\" , 6 => \"Northeast Gulf\" , 7 => \"Southeast Gulf\" ) julia > popid! ( sharks , rename = new_popnames ) output 212\u00d72 DataFrame \u2502 Row \u2502 ind \u2502 population \u2502 \u2502 \u2502 String \u2502 Union\u2026 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 cc_001 \u2502 Cape Canaveral \u2502 \u2502 2 \u2502 cc_002 \u2502 Cape Canaveral \u2502 \u2502 3 \u2502 cc_003 \u2502 Cape Canaveral \u2502 \u2502 4 \u2502 cc_005 \u2502 Cape Canaveral \u2502 \u2502 5 \u2502 cc_007 \u2502 Cape Canaveral \u2502 \u2502 6 \u2502 cc_008 \u2502 Cape Canaveral \u2502 \u2502 7 \u2502 cc_009 \u2502 Cape Canaveral \u2502 \u2502 8 \u2502 cc_010 \u2502 Cape Canaveral \u2502 \u2502 9 \u2502 cc_012 \u2502 Cape Canaveral \u2502 \u2502 10 \u2502 cc_013 \u2502 Cape Canaveral \u2502 \u2502 11 \u2502 cc_014 \u2502 Cape Canaveral \u2502 \u2502 12 \u2502 cc_015 \u2502 Cape Canaveral \u2502 \u2502 13 \u2502 cc_016 \u2502 Cape Canaveral \u2502 \u2502 14 \u2502 cc_017 \u2502 Cape Canaveral \u2502 \u2502 15 \u2502 cc_018 \u2502 Cape Canaveral \u2502 \u2502 16 \u2502 cc_019 \u2502 Cape Canaveral \u2502 \u2502 17 \u2502 cc_020 \u2502 Cape Canaveral \u2502 \u2502 18 \u2502 cc_021 \u2502 Cape Canaveral \u2502 \u22ee \u2502 194 \u2502 seg_003 \u2502 Southeast Gulf \u2502 \u2502 195 \u2502 seg_009 \u2502 Southeast Gulf \u2502 \u2502 196 \u2502 seg_010 \u2502 Southeast Gulf \u2502 \u2502 197 \u2502 seg_011 \u2502 Southeast Gulf \u2502 \u2502 198 \u2502 seg_012 \u2502 Southeast Gulf \u2502 \u2502 199 \u2502 seg_014 \u2502 Southeast Gulf \u2502 \u2502 200 \u2502 seg_015 \u2502 Southeast Gulf \u2502 \u2502 201 \u2502 seg_016 \u2502 Southeast Gulf \u2502 \u2502 202 \u2502 seg_018 \u2502 Southeast Gulf \u2502 \u2502 203 \u2502 seg_021 \u2502 Southeast Gulf \u2502 \u2502 204 \u2502 seg_023 \u2502 Southeast Gulf \u2502 \u2502 205 \u2502 seg_024 \u2502 Southeast Gulf \u2502 \u2502 206 \u2502 seg_025 \u2502 Southeast Gulf \u2502 \u2502 207 \u2502 seg_026 \u2502 Southeast Gulf \u2502 \u2502 208 \u2502 seg_027 \u2502 Southeast Gulf \u2502 \u2502 209 \u2502 seg_028 \u2502 Southeast Gulf \u2502 \u2502 210 \u2502 seg_029 \u2502 Southeast Gulf \u2502 \u2502 211 \u2502 seg_030 \u2502 Southeast Gulf \u2502 \u2502 212 \u2502 seg_031 \u2502 Southeast Gulf \u2502","title":"rename populations"},{"location":"commands/#genotypes-per-locus","text":"","title":"genotypes per locus"},{"location":"commands/#view-loci","text":"loci ( x :: PopObj , loci = nothing ) View the genotypes of all individuals for specific loci in a PopObj . Default shows all genotypes for all individuals. Returns a DataFrame. all loci julia > loci ( sharks ) output 212\u00d72215 DataFrames.DataFrame. Omitted printing of 2209 columns \u2502 Row \u2502 ind \u2502 population \u2502 contig_10001 \u2502 contig_10013 \u2502 contig_10028 \u2502 contig_10035 \u2502 \u2502 \u2502 String \u2502 Categorical\u2026 \u2502 Any \u2502 Any \u2502 Any \u2502 Any \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 cc_001 \u2502 1 \u2502 (1, 1) \u2502 (1, 1) \u2502 (1, 1) \u2502 (1, 1) \u2502 \u2502 2 \u2502 cc_002 \u2502 1 \u2502 (1, 1) \u2502 (1, 1) \u2502 (1, 1) \u2502 (1, 1) \u2502 \u2502 3 \u2502 cc_003 \u2502 1 \u2502 (1, 1) \u2502 (1, 1) \u2502 (2, 1) \u2502 (1, 1) \u2502 \u2502 4 \u2502 cc_005 \u2502 1 \u2502 (1, 1) \u2502 (1, 1) \u2502 (1, 1) \u2502 (2, 1) \u2502 \u2502 5 \u2502 cc_007 \u2502 1 \u2502 (1, 1) \u2502 (1, 1) \u2502 (2, 1) \u2502 (2, 1) \u2502 \u2502 6 \u2502 cc_008 \u2502 1 \u2502 (1, 1) \u2502 (1, 2) \u2502 (2, 1) \u2502 (1, 1) \u2502 \u2502 7 \u2502 cc_009 \u2502 1 \u2502 (1, 1) \u2502 (1, 2) \u2502 (2, 1) \u2502 (2, 1) \u2502 \u22ee \u2502 205 \u2502 seg_024 \u2502 7 \u2502 (1, 1) \u2502 (1, 1) \u2502 (1, 1) \u2502 (1, 1) \u2502 \u2502 206 \u2502 seg_025 \u2502 7 \u2502 (1, 1) \u2502 (1, 1) \u2502 (2, 1) \u2502 (2, 2) \u2502 \u2502 207 \u2502 seg_026 \u2502 7 \u2502 (1, 1) \u2502 (1, 1) \u2502 (2, 1) \u2502 (2, 2) \u2502 \u2502 208 \u2502 seg_027 \u2502 7 \u2502 (1, 1) \u2502 (1, 1) \u2502 (1, 1) \u2502 (2, 2) \u2502 \u2502 209 \u2502 seg_028 \u2502 7 \u2502 (1, 1) \u2502 (1, 1) \u2502 (2, 1) \u2502 (2, 2) \u2502 \u2502 210 \u2502 seg_029 \u2502 7 \u2502 (1, 1) \u2502 (1, 1) \u2502 (2, 1) \u2502 (2, 2) \u2502 \u2502 211 \u2502 seg_030 \u2502 7 \u2502 (1, 1) \u2502 (1, 1) \u2502 (2, 1) \u2502 (2, 2) \u2502 \u2502 212 \u2502 seg_031 \u2502 7 \u2502 (1, 1) \u2502 (1, 1) \u2502 (1, 1) \u2502 (1, 1) \u2502 Add a second argument (no keywords!) to specify a single locus (string) or multiple loci (array of strings) to display single locus julia > loci ( sharks , \"contig_10001\" ) single output 212\u00d73 DataFrames.DataFrame \u2502 Row \u2502 ind \u2502 population \u2502 contig_10001 \u2502 \u2502 \u2502 String \u2502 Categorical\u2026 \u2502 Any \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 cc_001 \u2502 1 \u2502 (1, 1) \u2502 \u2502 2 \u2502 cc_002 \u2502 1 \u2502 (1, 1) \u2502 \u2502 3 \u2502 cc_003 \u2502 1 \u2502 (1, 1) \u2502 \u2502 4 \u2502 cc_005 \u2502 1 \u2502 (1, 1) \u2502 \u2502 5 \u2502 cc_007 \u2502 1 \u2502 (1, 1) \u2502 \u2502 6 \u2502 cc_008 \u2502 1 \u2502 (1, 1) \u2502 \u2502 7 \u2502 cc_009 \u2502 1 \u2502 (1, 1) \u2502 \u22ee \u2502 205 \u2502 seg_024 \u2502 7 \u2502 (1, 1) \u2502 \u2502 206 \u2502 seg_025 \u2502 7 \u2502 (1, 1) \u2502 \u2502 207 \u2502 seg_026 \u2502 7 \u2502 (1, 1) \u2502 \u2502 208 \u2502 seg_027 \u2502 7 \u2502 (1, 1) \u2502 \u2502 209 \u2502 seg_028 \u2502 7 \u2502 (1, 1) \u2502 \u2502 210 \u2502 seg_029 \u2502 7 \u2502 (1, 1) \u2502 \u2502 211 \u2502 seg_030 \u2502 7 \u2502 (1, 1) \u2502 \u2502 212 \u2502 seg_031 \u2502 7 \u2502 (1, 1) \u2502 multiple loci julia > loci ( sharks , [ \"contig_10001\" , \"contig_10028\" ]) multiple output 212\u00d74 DataFrames.DataFrame \u2502 Row \u2502 ind \u2502 population \u2502 contig_10001 \u2502 contig_10028 \u2502 \u2502 \u2502 String \u2502 Categorical\u2026 \u2502 Any \u2502 Any \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 cc_001 \u2502 1 \u2502 (1, 1) \u2502 (1, 1) \u2502 \u2502 2 \u2502 cc_002 \u2502 1 \u2502 (1, 1) \u2502 (1, 1) \u2502 \u2502 3 \u2502 cc_003 \u2502 1 \u2502 (1, 1) \u2502 (2, 1) \u2502 \u2502 4 \u2502 cc_005 \u2502 1 \u2502 (1, 1) \u2502 (1, 1) \u2502 \u2502 5 \u2502 cc_007 \u2502 1 \u2502 (1, 1) \u2502 (2, 1) \u2502 \u2502 6 \u2502 cc_008 \u2502 1 \u2502 (1, 1) \u2502 (2, 1) \u2502 \u2502 7 \u2502 cc_009 \u2502 1 \u2502 (1, 1) \u2502 (2, 1) \u2502 \u22ee \u2502 205 \u2502 seg_024 \u2502 7 \u2502 (1, 1) \u2502 (1, 1) \u2502 \u2502 206 \u2502 seg_025 \u2502 7 \u2502 (1, 1) \u2502 (2, 1) \u2502 \u2502 207 \u2502 seg_026 \u2502 7 \u2502 (1, 1) \u2502 (2, 1) \u2502 \u2502 208 \u2502 seg_027 \u2502 7 \u2502 (1, 1) \u2502 (1, 1) \u2502 \u2502 209 \u2502 seg_028 \u2502 7 \u2502 (1, 1) \u2502 (2, 1) \u2502 \u2502 210 \u2502 seg_029 \u2502 7 \u2502 (1, 1) \u2502 (2, 1) \u2502 \u2502 211 \u2502 seg_030 \u2502 7 \u2502 (1, 1) \u2502 (2, 1) \u2502 \u2502 212 \u2502 seg_031 \u2502 7 \u2502 (1, 1) \u2502 (1, 1) \u2502","title":"view loci"},{"location":"commands/#remove-loci","text":"remove_loci! ( x :: PopObj , loci :: Union { String , Array { String , 1 }}) Removes selected loci from a PopObj . Input can be a single locus, or an array of loci. Examples: single locus julia > remove_loci! ( sharks , \"contig_35208\" ) ; julia > summary ( sharks ) single output Object of type PopObj: Longitude: [\"-80.59928\", \"-80.59954\", \"-80.59958\"] \u2026 [\"-87.36617\", \"-85.71432\", \"-85.71432\"] Latitude: [\"28.30624\", \"28.30787\", \"28.30234\"] \u2026 [\"30.05217\", \"29.82344\", \"29.82344\"] Number of individuals: 212 [\"cc_001\", \"cc_002\", \"cc_003\"] \u2026 [\"seg_029\", \"seg_030\", \"seg_031\"] Number of loci: 2212 [\"contig_23109\", \"contig_4493\", \"contig_10742\"] \u2026 [\"contig_19384\", \"contig_22368\", \"contig_2784\"] Ploidy: 2 Number of populations: 7 #Inds | Pop -------------- 21 | 1 30 | 2 28 | 3 65 | 4 28 | 5 20 | 6 20 | 7 Available fields: ind, popid, loci, ploidy, genotypes, longitude, latitude multiple loci julia > remove_loci! ( sharks , [ \"contig_35208\" , \"contig_23109\" , \"contig_4493\" ]) ; julia > summary ( sharks ) multiple output NOTICE: locus \"contig_35208\" not found Object of type PopObj: Longitude: [\"-80.59928\", \"-80.59954\", \"-80.59958\"] \u2026 [\"-87.36617\", \"-85.71432\", \"-85.71432\"] Latitude: [\"28.30624\", \"28.30787\", \"28.30234\"] \u2026 [\"30.05217\", \"29.82344\", \"29.82344\"] Number of individuals: 212 [\"cc_001\", \"cc_002\", \"cc_003\"] \u2026 [\"seg_029\", \"seg_030\", \"seg_031\"] Number of loci: 2210 [\"contig_10742\", \"contig_14898\", \"contig_8483\"] \u2026 [\"contig_19384\", \"contig_22368\", \"contig_2784\"] Ploidy: 2 Number of populations: 7 #Inds | Pop -------------- 21 | 1 30 | 2 28 | 3 65 | 4 28 | 5 20 | 6 20 | 7 Available fields: ind, popid, loci, ploidy, genotypes, longitude, latitude locus not found! If removing a single locus and it is not found in the PopObj, an error will be returned. However, if removing multiple loci, you will receive a notice above the PopObj summary indicating which loci were not found, while removing the ones that were.","title":"remove loci"},{"location":"commands/#genotypes-per-individual","text":"","title":"genotypes per individual"},{"location":"commands/#view-specific-genotypes","text":"Sometimes you want/need to view genotypes of specific individuals, and that's what genotypes is for. By default, the command will show you a DataFrame of the genotypes of all individuals for all loci. genotypes julia > genotypes ( sharks ) output 212\u00d72215 DataFrames.DataFrame. Omitted printing of 2209 columns \u2502 Row \u2502 ind \u2502 population \u2502 contig_10001 \u2502 contig_10013 \u2502 contig_10028 \u2502 contig_10035 \u2502 \u2502 \u2502 String \u2502 Categorical\u2026 \u2502 Any \u2502 Any \u2502 Any \u2502 Any \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 cc_001 \u2502 1 \u2502 (1, 1) \u2502 (1, 1) \u2502 (1, 1) \u2502 (1, 1) \u2502 \u2502 2 \u2502 cc_002 \u2502 1 \u2502 (1, 1) \u2502 (1, 1) \u2502 (1, 1) \u2502 (1, 1) \u2502 \u2502 3 \u2502 cc_003 \u2502 1 \u2502 (1, 1) \u2502 (1, 1) \u2502 (2, 1) \u2502 (1, 1) \u2502 \u2502 4 \u2502 cc_005 \u2502 1 \u2502 (1, 1) \u2502 (1, 1) \u2502 (1, 1) \u2502 (2, 1) \u2502 \u2502 5 \u2502 cc_007 \u2502 1 \u2502 (1, 1) \u2502 (1, 1) \u2502 (2, 1) \u2502 (2, 1) \u2502 \u2502 6 \u2502 cc_008 \u2502 1 \u2502 (1, 1) \u2502 (1, 2) \u2502 (2, 1) \u2502 (1, 1) \u2502 \u2502 7 \u2502 cc_009 \u2502 1 \u2502 (1, 1) \u2502 (1, 2) \u2502 (2, 1) \u2502 (2, 1) \u2502 \u22ee \u2502 205 \u2502 seg_024 \u2502 7 \u2502 (1, 1) \u2502 (1, 1) \u2502 (1, 1) \u2502 (1, 1) \u2502 \u2502 206 \u2502 seg_025 \u2502 7 \u2502 (1, 1) \u2502 (1, 1) \u2502 (2, 1) \u2502 (2, 2) \u2502 \u2502 207 \u2502 seg_026 \u2502 7 \u2502 (1, 1) \u2502 (1, 1) \u2502 (2, 1) \u2502 (2, 2) \u2502 \u2502 208 \u2502 seg_027 \u2502 7 \u2502 (1, 1) \u2502 (1, 1) \u2502 (1, 1) \u2502 (2, 2) \u2502 \u2502 209 \u2502 seg_028 \u2502 7 \u2502 (1, 1) \u2502 (1, 1) \u2502 (2, 1) \u2502 (2, 2) \u2502 \u2502 210 \u2502 seg_029 \u2502 7 \u2502 (1, 1) \u2502 (1, 1) \u2502 (2, 1) \u2502 (2, 2) \u2502 \u2502 211 \u2502 seg_030 \u2502 7 \u2502 (1, 1) \u2502 (1, 1) \u2502 (2, 1) \u2502 (2, 2) \u2502 \u2502 212 \u2502 seg_031 \u2502 7 \u2502 (1, 1) \u2502 (1, 1) \u2502 (1, 1) \u2502 (1, 1) \u2502 Using the inds = keyword argument, you can specify a single individual (string) or multiple individuals (array of strings) to view only a subset single genotypes julia > genotypes ( sharks , inds = \"key_037\" ) single output 1\u00d72215 DataFrames.DataFrame. Omitted printing of 2209 columns \u2502 Row \u2502 ind \u2502 population \u2502 contig_10001 \u2502 contig_10013 \u2502 contig_10028 \u2502 contig_10035 \u2502 \u2502 \u2502 String \u2502 Categorical\u2026 \u2502 Any \u2502 Any \u2502 Any \u2502 Any \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 key_037 \u2502 4 \u2502 (1, 1) \u2502 (1, 1) \u2502 (2, 1) \u2502 (2, 1) \u2502 multiple genotypes julia > genotypes ( sharks , inds = [ \"cc_008\" , \"meg_015\" ]) multiple output 2\u00d72215 DataFrames.DataFrame. Omitted printing of 2209 columns \u2502 Row \u2502 ind \u2502 population \u2502 contig_10001 \u2502 contig_10013 \u2502 contig_10028 \u2502 contig_10035 \u2502 \u2502 \u2502 String \u2502 Categorical\u2026 \u2502 Any \u2502 Any \u2502 Any \u2502 Any \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 cc_008 \u2502 1 \u2502 (1, 1) \u2502 (1, 2) \u2502 (2, 1) \u2502 (1, 1) \u2502 \u2502 2 \u2502 meg_015 \u2502 5 \u2502 (1, 1) \u2502 (1, 1) \u2502 (1, 1) \u2502 (2, 2) \u2502 Info Since many of the outputs of these functions are in DataFrame format, you have the flexibility to use the tools in DataFrames.jl as well as Query.jl to filter and subset these data even further.","title":"view specific genotypes"},{"location":"commands/#missing-data","text":"","title":"missing data"},{"location":"commands/#view-missing-data","text":"Used to show missingness information-- that is, loci missing allele information. This command outputs two DataFrames, the first being a count of number of missing loci per individual, the other being the number of times a locus is missing across individuals. missing julia > missing ( sharks ) output (212\u00d74 DataFrames.DataFrame. Omitted printing of 1 columns \u2502 Row \u2502 ind \u2502 population \u2502 nmissing \u2502 \u2502 \u2502 String \u2502 String \u2502 Any \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 cc_001 \u2502 1 \u2502 124 \u2502 \u2502 2 \u2502 cc_002 \u2502 1 \u2502 94 \u2502 \u2502 3 \u2502 cc_003 \u2502 1 \u2502 100 \u2502 \u2502 4 \u2502 cc_005 \u2502 1 \u2502 0 \u2502 \u2502 5 \u2502 cc_007 \u2502 1 \u2502 2 \u2502 \u2502 6 \u2502 cc_008 \u2502 1 \u2502 1 \u2502 \u2502 7 \u2502 cc_009 \u2502 1 \u2502 2 \u2502 \u22ee \u2502 205 \u2502 seg_024 \u2502 7 \u2502 0 \u2502 \u2502 206 \u2502 seg_025 \u2502 7 \u2502 0 \u2502 \u2502 207 \u2502 seg_026 \u2502 7 \u2502 0 \u2502 \u2502 208 \u2502 seg_027 \u2502 7 \u2502 2 \u2502 \u2502 209 \u2502 seg_028 \u2502 7 \u2502 25 \u2502 \u2502 210 \u2502 seg_029 \u2502 7 \u2502 0 \u2502 \u2502 211 \u2502 seg_030 \u2502 7 \u2502 1 \u2502 \u2502 212 \u2502 seg_031 \u2502 7 \u2502 1 \u2502, 2213\u00d72 DataFrames.DataFrame \u2502 Row \u2502 locus \u2502 nmissing \u2502 \u2502 \u2502 String \u2502 Any \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 contig_35208 \u2502 0 \u2502 \u2502 2 \u2502 contig_23109 \u2502 6 \u2502 \u2502 3 \u2502 contig_4493 \u2502 3 \u2502 \u2502 4 \u2502 contig_10742 \u2502 2 \u2502 \u2502 5 \u2502 contig_14898 \u2502 0 \u2502 \u2502 6 \u2502 contig_8483 \u2502 0 \u2502 \u2502 7 \u2502 contig_8065 \u2502 0 \u2502 \u22ee \u2502 2206 \u2502 contig_24711 \u2502 0 \u2502 \u2502 2207 \u2502 contig_18959 \u2502 0 \u2502 \u2502 2208 \u2502 contig_43517 \u2502 6 \u2502 \u2502 2209 \u2502 contig_27356 \u2502 2 \u2502 \u2502 2210 \u2502 contig_475 \u2502 0 \u2502 \u2502 2211 \u2502 contig_19384 \u2502 5 \u2502 \u2502 2212 \u2502 contig_22368 \u2502 3 \u2502 \u2502 2213 \u2502 contig_2784 \u2502 7 \u2502) Since missing outputs a tuple of dataframes, an easier way to use this function is with multiple assignment: missing julia > df1 , df2 = missing ( sharks ) ; df1 julia> df1 212\u00d74 DataFrames.DataFrame. Omitted printing of 1 columns \u2502 Row \u2502 ind \u2502 population \u2502 nmissing \u2502 \u2502 \u2502 String \u2502 String \u2502 Any \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 cc_001 \u2502 1 \u2502 124 \u2502 \u2502 2 \u2502 cc_002 \u2502 1 \u2502 94 \u2502 \u2502 3 \u2502 cc_003 \u2502 1 \u2502 100 \u2502 \u2502 4 \u2502 cc_005 \u2502 1 \u2502 0 \u2502 \u2502 5 \u2502 cc_007 \u2502 1 \u2502 2 \u2502 \u2502 6 \u2502 cc_008 \u2502 1 \u2502 1 \u2502 \u2502 7 \u2502 cc_009 \u2502 1 \u2502 2 \u2502 \u22ee \u2502 205 \u2502 seg_024 \u2502 7 \u2502 0 \u2502 \u2502 206 \u2502 seg_025 \u2502 7 \u2502 0 \u2502 \u2502 207 \u2502 seg_026 \u2502 7 \u2502 0 \u2502 \u2502 208 \u2502 seg_027 \u2502 7 \u2502 2 \u2502 \u2502 209 \u2502 seg_028 \u2502 7 \u2502 25 \u2502 \u2502 210 \u2502 seg_029 \u2502 7 \u2502 0 \u2502 \u2502 211 \u2502 seg_030 \u2502 7 \u2502 1 \u2502 \u2502 212 \u2502 seg_031 \u2502 7 \u2502 1 \u2502 df2 julia> df2 2213\u00d72 DataFrames.DataFrame \u2502 Row \u2502 locus \u2502 nmissing \u2502 \u2502 \u2502 String \u2502 Any \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 contig_35208 \u2502 0 \u2502 \u2502 2 \u2502 contig_23109 \u2502 6 \u2502 \u2502 3 \u2502 contig_4493 \u2502 3 \u2502 \u2502 4 \u2502 contig_10742 \u2502 2 \u2502 \u2502 5 \u2502 contig_14898 \u2502 0 \u2502 \u2502 6 \u2502 contig_8483 \u2502 0 \u2502 \u2502 7 \u2502 contig_8065 \u2502 0 \u2502 \u22ee \u2502 2206 \u2502 contig_24711 \u2502 0 \u2502 \u2502 2207 \u2502 contig_18959 \u2502 0 \u2502 \u2502 2208 \u2502 contig_43517 \u2502 6 \u2502 \u2502 2209 \u2502 contig_27356 \u2502 2 \u2502 \u2502 2210 \u2502 contig_475 \u2502 0 \u2502 \u2502 2211 \u2502 contig_19384 \u2502 5 \u2502 \u2502 2212 \u2502 contig_22368 \u2502 3 \u2502 \u2502 2213 \u2502 contig_2784 \u2502 7 \u2502 Info Python has this feature, however, if you're migrating from R, multiple assignment probably looks weird, or like flat-out sorcery. Whenever a function returns a tuple of values, like missing does, you can assign as many variables to it at once. For example: a , b , c , d = ( 1 , 2 , 3 ,[ 4 , 5 , 6 , 7 ]) where a = 1 b = 2 c = 3 d = [4, 5, 6, 7] embrace the convenience!","title":"view missing data"},{"location":"commands/#plot-missing-data","text":"plot_missing ( x :: PopObj ; color = false ) Return an interactive plot of the number of missing loci in individuals of a PopObj , along with the number of missing individuals per locus. Use color = [color1, color2, ...] to set a custom color palette for the boxplots. Example: julia > plot_missing ( sharks ) saving interactive plots To save the interactive plots, you can use the savehtml function from the PlotlyJS.jl package: PlotlyJS . savehtml ( plot , \"filename.html\" ) If you don't specify a full path in the filename, it will save it in your current working directory. #example julia > using PlotlyJS ; julia > PlotlyJS . savehtml ( plot_missing ( sharks ), \"/home/pdimens/missingness.html\" ) use a third argument :embed to make the plots fully viewable offline. The output files are much larger (relatively) because it embeds the Plotly javeascript into the file. For context, the gulfsharks plot file is ~3.5mb when using :embed \u200b \u200b","title":"plot missing data"},{"location":"commands/#location-data","text":"","title":"location data"},{"location":"commands/#view-location-data","text":"locations ( x :: PopObj ) View location data ( .longitude and .latitude ) in a PopObj If you want to do your own plotting, or just to look at the spatial data of your PopObj, this function is handy. It takes no additional arguments and outputs a DataFrame of individual names, population ID's, and their latitude/longitude information. locations julia > locations ( sharks ) output 212\u00d74 DataFrames.DataFrame \u2502 Row \u2502 ind \u2502 population \u2502 longitude \u2502 latitude \u2502 \u2502 \u2502 String \u2502 Union\u2026 \u2502 Union\u2026 \u2502 Union\u2026 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 cc_001 \u2502 1 \u2502 -80.5993 \u2502 28.3062 \u2502 \u2502 2 \u2502 cc_002 \u2502 1 \u2502 -80.5995 \u2502 28.3079 \u2502 \u2502 3 \u2502 cc_003 \u2502 1 \u2502 -80.5996 \u2502 28.3023 \u2502 \u2502 4 \u2502 cc_005 \u2502 1 \u2502 -80.4225 \u2502 28.6123 \u2502 \u2502 5 \u2502 cc_007 \u2502 1 \u2502 -80.3578 \u2502 27.8666 \u2502 \u2502 6 \u2502 cc_008 \u2502 1 \u2502 -80.3579 \u2502 27.8666 \u2502 \u2502 7 \u2502 cc_009 \u2502 1 \u2502 -80.3482 \u2502 27.8682 \u2502 \u22ee \u2502 205 \u2502 seg_024 \u2502 7 \u2502 -87.4403 \u2502 29.6966 \u2502 \u2502 206 \u2502 seg_025 \u2502 7 \u2502 -86.5374 \u2502 30.064 \u2502 \u2502 207 \u2502 seg_026 \u2502 7 \u2502 -86.5376 \u2502 30.0696 \u2502 \u2502 208 \u2502 seg_027 \u2502 7 \u2502 -86.0905 \u2502 29.9065 \u2502 \u2502 209 \u2502 seg_028 \u2502 7 \u2502 -87.3661 \u2502 30.0532 \u2502 \u2502 210 \u2502 seg_029 \u2502 7 \u2502 -87.3662 \u2502 30.0522 \u2502 \u2502 211 \u2502 seg_030 \u2502 7 \u2502 -85.7143 \u2502 29.8234 \u2502 \u2502 212 \u2502 seg_031 \u2502 7 \u2502 -85.7143 \u2502 29.8234 \u2502 locations secondary feature There is a built-in component in locations to test if the location data 1) exists, and 2) is of equal length, or it will spit out an error. It's probably a good idea to do this for your data at least once to be assured everything is ok!","title":"view location data"},{"location":"commands/#add-location-data","text":"Location data can be added by directly accessing the fields .longitude and .latitude in your PopObj , such as this example: julia > sharks . longitude = rand ( 1 : 50 , 212 ) ; # creates 212 unique random numbers between 1 and 50 julia > sharks . latitdue = rand ( 20 : 30 , 212 ) ; # creates 212 unique random numbers between 20 and 30 However, if your data is in decimal minutes rather than decimal degrees, use the locations! function to add it to the fields. This function will do a conversion from decimal minutes to decimal degrees for you. To import those data into Julia, you'll likely want to use the wonderful CSV.jl package first.","title":"add location data"},{"location":"commands/#decimal-minutes-data","text":"locations! ( x :: PopObj ; xloc :: Array , yloc :: Array ) Adds location data (longitude, latitude) to PopObj . Takes decimal degrees or decimal minutes format. Must use minus-sign instead of cardinal directions (i.e. 14 32.11W is not vaild). Location data must be in order of individuals ( ind ). Replaces existing PopObj location data. Decimal Degrees : -11.431 Decimal Minutes : \"-11 43.11\" (must use space and double-quotes) If conversion is not necessary, can directly assign PopObj.longitude and PopObj.latitude as shown above. If you still wanted to use locations! but don't need a conversion, it still works: julia > long = a . longitude = rand ( 1 : 50 , 212 ) ; julia > lat = a . latitdue = rand ( 20 : 30 , 212 ) ; julia > locations! ( a , long , lat ) ;","title":"decimal minutes data"},{"location":"commands/#plot-location-data","text":"You're encouraged to plot locations however you think is best. For convenience and speed, we provide a plot_locations command to make a decent, albeit simple interactive plot (Plotly) and save some time. Have a look at the command in more detail under \"Functions\" for some configuration options. julia > plot_locations ( sharks )","title":"plot location data"},{"location":"contr/","text":"Contributing We absolutely welcome contributors to this package/project! Contributing can take the form of: Optimizing available code Pointing out bugs (and troubleshooting them if possible!) Testing your data against the available code Writing new functions or methods for existing functions Writing or editing the docs Spreading the word on social media Words of encouragement","title":"Contributing"},{"location":"contr/#contributing","text":"We absolutely welcome contributors to this package/project! Contributing can take the form of: Optimizing available code Pointing out bugs (and troubleshooting them if possible!) Testing your data against the available code Writing new functions or methods for existing functions Writing or editing the docs Spreading the word on social media Words of encouragement","title":"Contributing"},{"location":"delimited/","text":"Formatting Loci names must be first row Individuals names must be first value in row Population ID's must be second value in row Optional: longitude (x) values third value in row, latitude (y) fourth value in row Formatting examples without locations Locus1,Locus2,Locus3 sierra_01,1,001001,002002,001001 sierra_02,1,001001,001001,001002 snbarb_03,2,001001,001001,001002 snbarb_02,2,001001,001001,001001 snbarb_03,2,001002,001001,001001 with locations Locus1,Locus2,Locus3 sierra_01,1,14.1,15.2,001001,002002,001001 sierra_02,1,34.1,26.1,001001,001001,001002 snbarb_03,2,45.1,-11.2,001001,001001,001002 snbarb_02,2,-11.5,11.6,001001,001001,001001 snbarb_03,2,-3.1,43.2,001002,001001,001001 Importing a CSV into Julia as a PopObj Windows users make sure to change your backslashes \"\\\" to forward slashes \"/\" csv ( infile ; delim , ploidy = 2 , location = false ) # Example julia > a = csv ( \"/data/cali_poppy.csv\" , delim = \",\" , ploidy = 2 ) Arguments infile :: String : path to the input file, in quotes Keyword Arguments delim :: Union { Char , String , Regex } : delimiter of the file, can be a string, character, or regex comma: delim = \",\" space: delim = \" \" tab: delim = \"\\t\" etc. ploidy :: Int64 : single integer of the ploidy of the samples in the file (default = 2) haploid: ploidy = 1 diploid: ploidy = 2 triploid: ploidy = 3 etc. location :: Bool = false : true/false of whether location data is present in the file (default = false)","title":"CSV and delimited"},{"location":"delimited/#formatting","text":"Loci names must be first row Individuals names must be first value in row Population ID's must be second value in row Optional: longitude (x) values third value in row, latitude (y) fourth value in row","title":"Formatting"},{"location":"delimited/#formatting-examples","text":"without locations Locus1,Locus2,Locus3 sierra_01,1,001001,002002,001001 sierra_02,1,001001,001001,001002 snbarb_03,2,001001,001001,001002 snbarb_02,2,001001,001001,001001 snbarb_03,2,001002,001001,001001 with locations Locus1,Locus2,Locus3 sierra_01,1,14.1,15.2,001001,002002,001001 sierra_02,1,34.1,26.1,001001,001001,001002 snbarb_03,2,45.1,-11.2,001001,001001,001002 snbarb_02,2,-11.5,11.6,001001,001001,001001 snbarb_03,2,-3.1,43.2,001002,001001,001001","title":"Formatting examples"},{"location":"delimited/#importing-a-csv-into-julia-as-a-popobj","text":"Windows users make sure to change your backslashes \"\\\" to forward slashes \"/\" csv ( infile ; delim , ploidy = 2 , location = false ) # Example julia > a = csv ( \"/data/cali_poppy.csv\" , delim = \",\" , ploidy = 2 )","title":"Importing a CSV into Julia as a PopObj"},{"location":"delimited/#arguments","text":"infile :: String : path to the input file, in quotes","title":"Arguments"},{"location":"delimited/#keyword-arguments","text":"delim :: Union { Char , String , Regex } : delimiter of the file, can be a string, character, or regex comma: delim = \",\" space: delim = \" \" tab: delim = \"\\t\" etc. ploidy :: Int64 : single integer of the ploidy of the samples in the file (default = 2) haploid: ploidy = 1 diploid: ploidy = 2 triploid: ploidy = 3 etc. location :: Bool = false : true/false of whether location data is present in the file (default = false)","title":"Keyword Arguments"},{"location":"examples/","text":"PopGen.jl provides two datasets as examples, each with their own easy-to-remember function for retrieving those data. nancycats We include the familiar nancycats microsatellite data, as featured in adegenet , for easy importing into PopGen.jl as a PopObj . To use those data, simply invoke nancycats() without any arguments. julia> ncats = nancycats() Object of type PopObj: No location data provided Number of individuals: 237 [\"N215\", \"N216\", \"N217\"] \u2026 [\"N281\", \"N289\", \"N290\"] Number of loci: 9 [\"fca8\", \"fca23\", \"fca43\"] \u2026 [\"fca90\", \"fca96\", \"fca37\"] Ploidy: 2 Number of populations: 17 #Inds | Pop -------------- 10 | 1 22 | 2 12 | 3 23 | 4 15 | 5 11 | 6 14 | 7 10 | 8 9 | 9 11 | 10 20 | 11 14 | 12 13 | 13 17 | 14 11 | 15 12 | 16 13 | 17 Available fields: ind, popid, loci, ploidy, genotypes, longitude, latitude The spatial coordinates provided for the dataset in adegenet are completely unfamiliar to us (and some geospatial folks we spoke to), so they have been omitted. If you recognize what coordinate system has 485.111 appear in Nancy, France, please let us know! gulfsharks We also include the SNP dataset used in Dimens et al. 2019 \" A genomic assessment of movement and gene flow around the South Florida vicariance zone in the migratory coastal blacknose shark , Carcharhinus acronotus \" since it was already on hand. Like nancycats , we provide a convenient function to load these data into PopGen.jl as a PopObj . To use those data, simply invoke gulfsharks() without any arguments. julia> sharks = gulfsharks() Object of type PopObj: Longitude: [\"-80.59928\", \"-80.59954\", \"-80.59958\"] \u2026 [\"-87.36617\", \"-85.71432\", \"-85.71432\"] Latitude: [\"28.30624\", \"28.30787\", \"28.30234\"] \u2026 [\"30.05217\", \"29.82344\", \"29.82344\"] Number of individuals: 212 [\"cc_001\", \"cc_002\", \"cc_003\"] \u2026 [\"seg_029\", \"seg_030\", \"seg_031\"] Number of loci: 2213 [\"contig_35208\", \"contig_23109\", \"contig_4493\"] \u2026 [\"contig_19384\", \"contig_22368\", \"contig_2784\"] Ploidy: 2 Number of populations: 7 #Inds | Pop -------------- 21 | 1 30 | 2 28 | 3 65 | 4 28 | 5 20 | 6 20 | 7 Available fields: ind, popid, loci, ploidy, genotypes, longitude, latitude","title":"Example data"},{"location":"examples/#nancycats","text":"We include the familiar nancycats microsatellite data, as featured in adegenet , for easy importing into PopGen.jl as a PopObj . To use those data, simply invoke nancycats() without any arguments. julia> ncats = nancycats() Object of type PopObj: No location data provided Number of individuals: 237 [\"N215\", \"N216\", \"N217\"] \u2026 [\"N281\", \"N289\", \"N290\"] Number of loci: 9 [\"fca8\", \"fca23\", \"fca43\"] \u2026 [\"fca90\", \"fca96\", \"fca37\"] Ploidy: 2 Number of populations: 17 #Inds | Pop -------------- 10 | 1 22 | 2 12 | 3 23 | 4 15 | 5 11 | 6 14 | 7 10 | 8 9 | 9 11 | 10 20 | 11 14 | 12 13 | 13 17 | 14 11 | 15 12 | 16 13 | 17 Available fields: ind, popid, loci, ploidy, genotypes, longitude, latitude The spatial coordinates provided for the dataset in adegenet are completely unfamiliar to us (and some geospatial folks we spoke to), so they have been omitted. If you recognize what coordinate system has 485.111 appear in Nancy, France, please let us know!","title":"nancycats"},{"location":"examples/#gulfsharks","text":"We also include the SNP dataset used in Dimens et al. 2019 \" A genomic assessment of movement and gene flow around the South Florida vicariance zone in the migratory coastal blacknose shark , Carcharhinus acronotus \" since it was already on hand. Like nancycats , we provide a convenient function to load these data into PopGen.jl as a PopObj . To use those data, simply invoke gulfsharks() without any arguments. julia> sharks = gulfsharks() Object of type PopObj: Longitude: [\"-80.59928\", \"-80.59954\", \"-80.59958\"] \u2026 [\"-87.36617\", \"-85.71432\", \"-85.71432\"] Latitude: [\"28.30624\", \"28.30787\", \"28.30234\"] \u2026 [\"30.05217\", \"29.82344\", \"29.82344\"] Number of individuals: 212 [\"cc_001\", \"cc_002\", \"cc_003\"] \u2026 [\"seg_029\", \"seg_030\", \"seg_031\"] Number of loci: 2213 [\"contig_35208\", \"contig_23109\", \"contig_4493\"] \u2026 [\"contig_19384\", \"contig_22368\", \"contig_2784\"] Ploidy: 2 Number of populations: 7 #Inds | Pop -------------- 21 | 1 30 | 2 28 | 3 65 | 4 28 | 5 20 | 6 20 | 7 Available fields: ind, popid, loci, ploidy, genotypes, longitude, latitude","title":"gulfsharks"},{"location":"genepop/","text":"Format Files must follow standard Genepop formatting: First line is a comment (and skipped) Loci are listed after first line as one-per-line without commas or in single comma-separated row A line with a particular keyword must delimit populations Must be the same word each time and not a unique population name File is tab or space delimted Formatting Examples loci stacked vertically Wasp populations in New York Locus1 Locus2 Locus3 POP Oneida_01, 250230 564568 110100 Oneida_02, 252238 568558 100120 Oneida_03, 254230 564558 090100 POP Newcomb_01, 254230 564558 080100 Newcomb_02, 000230 564558 090080 Newcomb_03, 254230 000000 090100 Newcomb_04, 254230 564000 090120 loci stacked horizontally Wasp populations in New York Locus1,Locus2,Locus3 POP Oneida_01, 250230 564568 110100 Oneida_02, 252238 568558 100120 Oneida_03, 254230 564558 090100 POP Newcomb_01, 254230 564558 080100 Newcomb_02, 000230 564558 090080 Newcomb_03, 254230 000000 090100 Newcomb_04, 254230 564000 090120 Import a genepop file into Julia as a PopObj Windows users make sure to change your backslashes \"\\\" to forward slashes \"/\" genepop ( infile ; ploidy = 2 , popsep = \"POP\" , numpops ) # Example julia > b = genepop ( \"/data/wasp_hive.gen\" , ploidy = 2 , popsep = \"POP\" , numpops = 2 ) Arguments infile::String : path to genepop file, in quotes Keyword Arguments ploidy::Int64 : single integer of the ploidy of the samples in the file (default = 2) haploid: ploidy = 1 diploid: ploidy = 2 triploid: ploidy = 3 etc. popsep::String : word that separates populations in infile (default: \"POP\") numpops::Int64 : number of populations present in infile (used for early error checking) Default population names By default, the file reader will assign numbers as population ID's in order of appearance in the genepop file. Use the popid! function to rename these with your own population ID's.","title":"Genepop"},{"location":"genepop/#format","text":"Files must follow standard Genepop formatting: First line is a comment (and skipped) Loci are listed after first line as one-per-line without commas or in single comma-separated row A line with a particular keyword must delimit populations Must be the same word each time and not a unique population name File is tab or space delimted","title":"Format"},{"location":"genepop/#formatting-examples","text":"loci stacked vertically Wasp populations in New York Locus1 Locus2 Locus3 POP Oneida_01, 250230 564568 110100 Oneida_02, 252238 568558 100120 Oneida_03, 254230 564558 090100 POP Newcomb_01, 254230 564558 080100 Newcomb_02, 000230 564558 090080 Newcomb_03, 254230 000000 090100 Newcomb_04, 254230 564000 090120 loci stacked horizontally Wasp populations in New York Locus1,Locus2,Locus3 POP Oneida_01, 250230 564568 110100 Oneida_02, 252238 568558 100120 Oneida_03, 254230 564558 090100 POP Newcomb_01, 254230 564558 080100 Newcomb_02, 000230 564558 090080 Newcomb_03, 254230 000000 090100 Newcomb_04, 254230 564000 090120","title":"Formatting Examples"},{"location":"genepop/#import-a-genepop-file-into-julia-as-a-popobj","text":"Windows users make sure to change your backslashes \"\\\" to forward slashes \"/\" genepop ( infile ; ploidy = 2 , popsep = \"POP\" , numpops ) # Example julia > b = genepop ( \"/data/wasp_hive.gen\" , ploidy = 2 , popsep = \"POP\" , numpops = 2 )","title":"Import a genepop file into Julia as a PopObj"},{"location":"genepop/#arguments","text":"infile::String : path to genepop file, in quotes","title":"Arguments"},{"location":"genepop/#keyword-arguments","text":"ploidy::Int64 : single integer of the ploidy of the samples in the file (default = 2) haploid: ploidy = 1 diploid: ploidy = 2 triploid: ploidy = 3 etc. popsep::String : word that separates populations in infile (default: \"POP\") numpops::Int64 : number of populations present in infile (used for early error checking) Default population names By default, the file reader will assign numbers as population ID's in order of appearance in the genepop file. Use the popid! function to rename these with your own population ID's.","title":"Keyword Arguments"},{"location":"install/","text":"Installation Installing PopGen.jl The package is currently unregistered while it's under active early development. However, installation is still simple! Invoke the package manager with ] in the REPL and use add \"https://github.com/pdimens/PopGen.jl\" If using Jupyter Notebooks or nteract, install the package in julia with using Pkg Pkg . add ( \"https://github.com/pdimens/PopGen.jl\" ) Feel free to play around with the test data in /test/testdata.gen Using PopGen Like all Julia packages, to activate PopGen , simply run: julia > using PopGen Performance notes If you're migrating to Julia from Python or R (or Matlab, etc.), you'll think Julia is slow and laggy because loading packages and running stuff has a noticeable wait time (10-40sec). However, if this is your first time in Julia, then it's worth mentioning that this lag is \"compilation overhead\". What this means is, Julia tries to pre-compile as much code as possible (into optimized machine code) when running something or loading a package. This lag exists only the first time you run something. Every subsequent run of a function, even with different parameters, will be substantially faster, and in most cases instant. If you want to test this yourself, try to run a line of code twice with @time before the function and compare the results. Here's an example: julia> @time using PopGen 17.415902 seconds (19.88 M allocations: 1.022 GiB, 2.79% gc time) julia> @time using PopGen 0.100233 seconds (64.07 k allocations: 3.123 MiB, 6.02% gc time)","title":"Installing"},{"location":"install/#installation","text":"","title":"Installation"},{"location":"install/#installing-popgenjl","text":"The package is currently unregistered while it's under active early development. However, installation is still simple! Invoke the package manager with ] in the REPL and use add \"https://github.com/pdimens/PopGen.jl\" If using Jupyter Notebooks or nteract, install the package in julia with using Pkg Pkg . add ( \"https://github.com/pdimens/PopGen.jl\" ) Feel free to play around with the test data in /test/testdata.gen","title":"Installing PopGen.jl"},{"location":"install/#using-popgen","text":"Like all Julia packages, to activate PopGen , simply run: julia > using PopGen Performance notes If you're migrating to Julia from Python or R (or Matlab, etc.), you'll think Julia is slow and laggy because loading packages and running stuff has a noticeable wait time (10-40sec). However, if this is your first time in Julia, then it's worth mentioning that this lag is \"compilation overhead\". What this means is, Julia tries to pre-compile as much code as possible (into optimized machine code) when running something or loading a package. This lag exists only the first time you run something. Every subsequent run of a function, even with different parameters, will be substantially faster, and in most cases instant. If you want to test this yourself, try to run a line of code twice with @time before the function and compare the results. Here's an example: julia> @time using PopGen 17.415902 seconds (19.88 M allocations: 1.022 GiB, 2.79% gc time) julia> @time using PopGen 0.100233 seconds (64.07 k allocations: 3.123 MiB, 6.02% gc time)","title":"Using PopGen"},{"location":"juliaprimer/","text":"A quick Julia primer for getting the most out of this documentation There is nothing inherently special about this documentation relative to other documentation, other than we really really want you to get the most out of what's written here. This means that we need to embrace the fact that both novice and experienced Julia users may be reading these docs and using this package. So let's cover some Julia basics that will really help in navigating this package before we even get into the complicated genetics stuff. This primer is by no means \"everything you need to get started in Julia\", and is a poor substitute for actually learning the language. In general, we recommend Think Julia: How to Think Like a Data Scientist by Ben Lauwens to establish some solid Julia foundations. It's free online! Semicolons Semicolons will come up a lot in Julia, probably more than you would expect if you are migrating from another language. They mean different thing depending on where they are. At the end of a command When you see a semicolon after invoking a function, what that means is \"don't show me the output in the terminal window\". Example: julia > x = 2 + 2 4 julia > x = 10 + 2 ; julia > x 12 Julia will still process the command and assign 10 + 2 to x , but it won't show you the output in the terminal. We sometimes include a semicolon after commands in these docs to mimic what the REPL output would look like without spitting back out an array of over 200 values. These semicolons are optional In between assignment commands If you see a semicolon in between two variable assignments, like so: x = [ 1 , 2 ] ; y = [ 3 , 4 ] that's a Julia short-hand for making two short lines of code appear on a single line. It's the equivalent of doing: x = [ 1 , 2 ] y = [ 3 , 4 ] We sometimes choose this writing format for very quick and small assignments hoping to save some visual space. Use whichever method is most comfortable and sensible for you! Help mode To enter help mode in the REPL, simply press the question mark key ? (shift + key) and you will notice a different prompt help?> for you to type in a function. help ?> popid search: popid popid! popfirst! popdisplay precompile __precompile__ CompositeException popid(x::PopObj; listall::Bool = false) View unique population ID's in a PopObj. listall = true, displays ind and their popid instead (default = false). Type information Julia encourages strong typing of variables, and the functions in PopGen are no exception to this. However, to reduce the barrier of entry required to understand this documentation and the subsequent package, we have chosen to omit some of the type information from functions to reduce visual clutter for newer users. As experienced users already know, if you would like to see the explicit type information, you can look at the code on github, invoke the help system in the REPL (above), or search for a function in the Documentation pane in Juno. You'll notice types follow a specific format, which is object::type . This format is a type assignment, so in the function popid , which looks like: popid(x::PopObj; listall::Bool = false) : x is a variable of type PopObj listall is a variable of type Bool (boolean) meaning it only takes true or false without quotes Type Unions You might see the type Union appear occasionally throughout this documentation, and you can consider it a list of types. For example, if something was of type ::Union{String,Integer} , that means that either a String or Integer works. These kinds of Union appear in a few places, like remove_inds! , where the input can be either a String (a single individual) or an Array{String,1} (one-dimensional list of names). For remove_inds! , the second argument type appears as ::Union{String, Array{String,1}} . Also, the order in which types appear in Union types don't matter. Functions vs. Methods As part of Julia's type-safe paradigm and multiple dispatch (see \"ERROR: MethodError: no method matching\" below), type specifications in functions often reduce runtime of functions, but also establish function identity. Multiple dispatch refers to several different functions having the same name, but employing different methods depending on the input. In Julia, it's easier to write a single function with multiple type-safe methods, rather than one mega-function that accepts any type and have a bunch of if statements that determines what the program does depending on the input. In practice, this looks like: # combine two numbers julia> function add(x::Integer, y::Integer) x+y end add (generic function with 1 method) # combine two strings julia> function add(x::String, y::String) x*y end add (generic function with 2 methods) julia> add(1,2) 3 julia> add(\"water\", \"melon\") \"watermelon\" Multiple dispatch therefor leads to a unique type of possible error: the MethodError ERROR: MethodError: no method matching Using the function add from the example above, let's have a look at what happens when we try to add an Integer with a String : julia > add ( 1 , \"melon\" ) ERROR : MethodError : no method matching add ( :: Int64 , :: String ) Closest candidates are : add ( :: String , :: String ) at none : 2 add ( :: Integer , :: Integer ) at none : 2 Stacktrace : [ 1 ] top - level scope at none : 0 This error is telling us \"there is no such function called add , who's inputs are an Integer followed by a String \". But, it does offer us some alternatives, like the two add functions we created earlier. The functions within PopGen are almost always explicitly typed, so if you are getting the MethodError: no method matching error, then you are inputting the incorrect types into the function, or perhaps your inputs for the arguments are in the wrong order (see \"Functions with and without keywords\" below). keep in mind MethodError's can definitely get annoying, but they are usually the result of incorrect input from the user and not buggy programming by the developers. Please take that into consideration before assuming something is broken or bugged. Functions with and without keywords TL;DR Reading these docs, pay attention to semicolons in the function argument lists. arguments before a semicolon have no keyword and follow an explicit order arguments after a semicolon have a keyword argument = value and their order doesn't matter MethodError: no methods matching is more likely an issue on your side and not on our side unless we accidentally forgot to export a function! Broadly speaking, there are two types of function declarations in Julia: ones with keywords and ones without keywords. The term \"keywords\" refers to an input argument that has the format argument = value . This format is present in many of the functions in this and other packages, however there are some specifics to understand when functions use keywords and when they don't. Format 1: Strict argument order and no keywords - No semicolon in argument list function function_name ( var1 :: type , var2 :: type , var3 :: type ) do stuff with vars end If a function is declared with only commas in the argument list, like shown above, then the arguments to that function must have no keywords and follow the exact order they appear in. If the generic example above had the typing: function function_name ( var1 :: String , var2 :: Float64 , var3 :: Array { String , 1 }) do stuff with vars end then the only acceptable way to run this function without getting a MethodError would be with arguments in the order of function_name(String, Float64, Array{String,1}) . Even if some of the arguments have a default values, like var2::Float64 = 6.66 , the order of arguments/types has to be respected as declared. Format 2 - semicolon in argument list function function_name ( var1 :: type ; var2 :: type , var3 :: type ) do stuff with vars end In this format, everything that comes before the semicolon follows the strict rules from Format 1 , and everything that comes after the semicolon is a keyword argument. Keyword arguments have the flexibility to not require any particular input order. However, you must use the keywords to declare those arguments, or you will receive another MethodError: no method matching , which is, as we've mentioned, annoying.","title":"Getting started"},{"location":"juliaprimer/#a-quick-julia-primer-for-getting-the-most-out-of-this-documentation","text":"There is nothing inherently special about this documentation relative to other documentation, other than we really really want you to get the most out of what's written here. This means that we need to embrace the fact that both novice and experienced Julia users may be reading these docs and using this package. So let's cover some Julia basics that will really help in navigating this package before we even get into the complicated genetics stuff. This primer is by no means \"everything you need to get started in Julia\", and is a poor substitute for actually learning the language. In general, we recommend Think Julia: How to Think Like a Data Scientist by Ben Lauwens to establish some solid Julia foundations. It's free online!","title":"A quick Julia primer for getting the most out of this documentation"},{"location":"juliaprimer/#semicolons","text":"Semicolons will come up a lot in Julia, probably more than you would expect if you are migrating from another language. They mean different thing depending on where they are.","title":"Semicolons"},{"location":"juliaprimer/#at-the-end-of-a-command","text":"When you see a semicolon after invoking a function, what that means is \"don't show me the output in the terminal window\". Example: julia > x = 2 + 2 4 julia > x = 10 + 2 ; julia > x 12 Julia will still process the command and assign 10 + 2 to x , but it won't show you the output in the terminal. We sometimes include a semicolon after commands in these docs to mimic what the REPL output would look like without spitting back out an array of over 200 values. These semicolons are optional","title":"At the end of a command"},{"location":"juliaprimer/#in-between-assignment-commands","text":"If you see a semicolon in between two variable assignments, like so: x = [ 1 , 2 ] ; y = [ 3 , 4 ] that's a Julia short-hand for making two short lines of code appear on a single line. It's the equivalent of doing: x = [ 1 , 2 ] y = [ 3 , 4 ] We sometimes choose this writing format for very quick and small assignments hoping to save some visual space. Use whichever method is most comfortable and sensible for you!","title":"In between assignment commands"},{"location":"juliaprimer/#help-mode","text":"To enter help mode in the REPL, simply press the question mark key ? (shift + key) and you will notice a different prompt help?> for you to type in a function. help ?> popid search: popid popid! popfirst! popdisplay precompile __precompile__ CompositeException popid(x::PopObj; listall::Bool = false) View unique population ID's in a PopObj. listall = true, displays ind and their popid instead (default = false).","title":"Help mode"},{"location":"juliaprimer/#type-information","text":"Julia encourages strong typing of variables, and the functions in PopGen are no exception to this. However, to reduce the barrier of entry required to understand this documentation and the subsequent package, we have chosen to omit some of the type information from functions to reduce visual clutter for newer users. As experienced users already know, if you would like to see the explicit type information, you can look at the code on github, invoke the help system in the REPL (above), or search for a function in the Documentation pane in Juno. You'll notice types follow a specific format, which is object::type . This format is a type assignment, so in the function popid , which looks like: popid(x::PopObj; listall::Bool = false) : x is a variable of type PopObj listall is a variable of type Bool (boolean) meaning it only takes true or false without quotes","title":"Type information"},{"location":"juliaprimer/#type-unions","text":"You might see the type Union appear occasionally throughout this documentation, and you can consider it a list of types. For example, if something was of type ::Union{String,Integer} , that means that either a String or Integer works. These kinds of Union appear in a few places, like remove_inds! , where the input can be either a String (a single individual) or an Array{String,1} (one-dimensional list of names). For remove_inds! , the second argument type appears as ::Union{String, Array{String,1}} . Also, the order in which types appear in Union types don't matter.","title":"Type Unions"},{"location":"juliaprimer/#functions-vs-methods","text":"As part of Julia's type-safe paradigm and multiple dispatch (see \"ERROR: MethodError: no method matching\" below), type specifications in functions often reduce runtime of functions, but also establish function identity. Multiple dispatch refers to several different functions having the same name, but employing different methods depending on the input. In Julia, it's easier to write a single function with multiple type-safe methods, rather than one mega-function that accepts any type and have a bunch of if statements that determines what the program does depending on the input. In practice, this looks like: # combine two numbers julia> function add(x::Integer, y::Integer) x+y end add (generic function with 1 method) # combine two strings julia> function add(x::String, y::String) x*y end add (generic function with 2 methods) julia> add(1,2) 3 julia> add(\"water\", \"melon\") \"watermelon\" Multiple dispatch therefor leads to a unique type of possible error: the MethodError","title":"Functions vs. Methods"},{"location":"juliaprimer/#error-methoderror-no-method-matching","text":"Using the function add from the example above, let's have a look at what happens when we try to add an Integer with a String : julia > add ( 1 , \"melon\" ) ERROR : MethodError : no method matching add ( :: Int64 , :: String ) Closest candidates are : add ( :: String , :: String ) at none : 2 add ( :: Integer , :: Integer ) at none : 2 Stacktrace : [ 1 ] top - level scope at none : 0 This error is telling us \"there is no such function called add , who's inputs are an Integer followed by a String \". But, it does offer us some alternatives, like the two add functions we created earlier. The functions within PopGen are almost always explicitly typed, so if you are getting the MethodError: no method matching error, then you are inputting the incorrect types into the function, or perhaps your inputs for the arguments are in the wrong order (see \"Functions with and without keywords\" below). keep in mind MethodError's can definitely get annoying, but they are usually the result of incorrect input from the user and not buggy programming by the developers. Please take that into consideration before assuming something is broken or bugged.","title":"ERROR: MethodError: no method matching"},{"location":"juliaprimer/#functions-with-and-without-keywords","text":"TL;DR Reading these docs, pay attention to semicolons in the function argument lists. arguments before a semicolon have no keyword and follow an explicit order arguments after a semicolon have a keyword argument = value and their order doesn't matter MethodError: no methods matching is more likely an issue on your side and not on our side unless we accidentally forgot to export a function! Broadly speaking, there are two types of function declarations in Julia: ones with keywords and ones without keywords. The term \"keywords\" refers to an input argument that has the format argument = value . This format is present in many of the functions in this and other packages, however there are some specifics to understand when functions use keywords and when they don't.","title":"Functions with and without keywords"},{"location":"juliaprimer/#format-1-strict-argument-order-and-no-keywords-no-semicolon-in-argument-list","text":"function function_name ( var1 :: type , var2 :: type , var3 :: type ) do stuff with vars end If a function is declared with only commas in the argument list, like shown above, then the arguments to that function must have no keywords and follow the exact order they appear in. If the generic example above had the typing: function function_name ( var1 :: String , var2 :: Float64 , var3 :: Array { String , 1 }) do stuff with vars end then the only acceptable way to run this function without getting a MethodError would be with arguments in the order of function_name(String, Float64, Array{String,1}) . Even if some of the arguments have a default values, like var2::Float64 = 6.66 , the order of arguments/types has to be respected as declared.","title":"Format 1: Strict argument order and no keywords - No semicolon in argument list"},{"location":"juliaprimer/#format-2-semicolon-in-argument-list","text":"function function_name ( var1 :: type ; var2 :: type , var3 :: type ) do stuff with vars end In this format, everything that comes before the semicolon follows the strict rules from Format 1 , and everything that comes after the semicolon is a keyword argument. Keyword arguments have the flexibility to not require any particular input order. However, you must use the keywords to declare those arguments, or you will receive another MethodError: no method matching , which is, as we've mentioned, annoying.","title":"Format 2 - semicolon in argument list"},{"location":"plotting/","text":"Plotting The output of many functions are formatted for use in your favorite Julia plotting environments, such as Plots , Makie , PlotlyJS , PyPlot , Gadfly , etc. However, some convenience plots are provided to assist with speedy data visualization and exploration. plot missing data plot_missing ( x :: PopObj ; color = false ) Return an interactive plot of the number of missing loci in individuals of a PopObj , along with the number of missing individuals per locus. To set a custom color palette for the boxplots, use color = [color1, color2, ...] Example: julia > plot_missing ( a ) If you would like to save the interactive plot as a local HTML file (does not require Plotly account): julia > using PlotlyJS julia > PlotlyJS . savehtml ( plot_missing ( a ), \"filename.html\" ) This will save it in the current working directly as whatever you replace filename.html with. If you want the file to work properly offline, add a third argument :embed , although be aware it inflates the file size (~3.5mb for the test data). plot sample locations plot_locations(x::PopObj; region = \"world\", projection = \"orthographic\") Returns a simple lower resolution interactive scatterplot of the individuals in a PopObj . Default region and projection are \"world\" and \"orthographic\", respectively. If a specific region is set, the plot will default to \"mercator\" projection unless projection = is used to specify a different one. You can freely zoom and pan this plot as you can any other Plotly plot. Example: julia > plot_locations ( a ) julia > plot_locations ( a , region = \"north america\" , projection = \"mercator\" ) ` regions usa europe asia africa north america south america projections equirectangular mercator orthographic natural earth kavrayskiy7 miller robinson eckert4 azimuthal equal area azimuthal equidistant conic equal area conic conformal conic equidistant gnomonic stereographic mollweide hammer transverse mercator albers usa winkel tripel aitoff sinusoidal Saving As before, you can save the plot to an HTML file: julia > using PlotlyJS julia > PlotlyJS . savehtml ( plot_locations ( a , region = \"north america\" , projection = \"mercator\" ), \"filename.html\" )","title":"Plotting"},{"location":"plotting/#plotting","text":"The output of many functions are formatted for use in your favorite Julia plotting environments, such as Plots , Makie , PlotlyJS , PyPlot , Gadfly , etc. However, some convenience plots are provided to assist with speedy data visualization and exploration.","title":"Plotting"},{"location":"plotting/#plot-missing-data","text":"plot_missing ( x :: PopObj ; color = false ) Return an interactive plot of the number of missing loci in individuals of a PopObj , along with the number of missing individuals per locus. To set a custom color palette for the boxplots, use color = [color1, color2, ...] Example: julia > plot_missing ( a ) If you would like to save the interactive plot as a local HTML file (does not require Plotly account): julia > using PlotlyJS julia > PlotlyJS . savehtml ( plot_missing ( a ), \"filename.html\" ) This will save it in the current working directly as whatever you replace filename.html with. If you want the file to work properly offline, add a third argument :embed , although be aware it inflates the file size (~3.5mb for the test data).","title":"plot missing data"},{"location":"plotting/#plot-sample-locations","text":"plot_locations(x::PopObj; region = \"world\", projection = \"orthographic\") Returns a simple lower resolution interactive scatterplot of the individuals in a PopObj . Default region and projection are \"world\" and \"orthographic\", respectively. If a specific region is set, the plot will default to \"mercator\" projection unless projection = is used to specify a different one. You can freely zoom and pan this plot as you can any other Plotly plot. Example: julia > plot_locations ( a ) julia > plot_locations ( a , region = \"north america\" , projection = \"mercator\" ) ` regions usa europe asia africa north america south america projections equirectangular mercator orthographic natural earth kavrayskiy7 miller robinson eckert4 azimuthal equal area azimuthal equidistant conic equal area conic conformal conic equidistant gnomonic stereographic mollweide hammer transverse mercator albers usa winkel tripel aitoff sinusoidal Saving As before, you can save the plot to an HTML file: julia > using PlotlyJS julia > PlotlyJS . savehtml ( plot_locations ( a , region = \"north america\" , projection = \"mercator\" ), \"filename.html\" )","title":"plot sample locations"},{"location":"popobj_location/","text":"Location Data Notice the No location data provided text on the second line of output when you show a PopObj , like demonstrated on the previous page. That text exists as a \"heads up\" rather than a warning because location data is optional for a PopObj . There are functions that use location information (e.g. locations and plot_locations ), but most don't, so it's not a dealbreaker. If you add location information, displaying the PopObj again will show you output now including this information: julia> a = gulfsharks() ; summary(a) Object of type PopObj: Longitude: [\"26\", \"7\", \"21\"] \u2026 [\"25\", \"26\", \"29\"] Latitude: [\"10\", \"10\", \"40\"] \u2026 [\"3\", \"5\", \"46\"] Number of individuals: 212 [\"cca_001\", \"cca_002\", \"cca_003\"] \u2026 [\"seg_029\", \"seg_030\", \"seg_031\"] Number of loci: 2213 [\"Contig_35208\", \"Contig_23109\", \"Contig_4493\"] \u2026 [\"Contig_19384\", \"Contig_22368\", \"Contig_2784\"] Ploidy: 2 Number of populations: 7 #Inds | Pop -------------- 21 | 1 30 | 2 28 | 3 65 | 4 28 | 5 20 | 6 20 | 7 Available fields: ind, popid, loci, ploidy, genotypes, longitude, latitude Info While showing a PopObj represents location data as strings, they are actually coded as integers or floating point numbers. This was a design decision to remove visual clutter, however we can easily revert it back to displaying Int or Float64 with type information if that's what users prefer.","title":"Location data"},{"location":"popobj_location/#location-data","text":"Notice the No location data provided text on the second line of output when you show a PopObj , like demonstrated on the previous page. That text exists as a \"heads up\" rather than a warning because location data is optional for a PopObj . There are functions that use location information (e.g. locations and plot_locations ), but most don't, so it's not a dealbreaker. If you add location information, displaying the PopObj again will show you output now including this information: julia> a = gulfsharks() ; summary(a) Object of type PopObj: Longitude: [\"26\", \"7\", \"21\"] \u2026 [\"25\", \"26\", \"29\"] Latitude: [\"10\", \"10\", \"40\"] \u2026 [\"3\", \"5\", \"46\"] Number of individuals: 212 [\"cca_001\", \"cca_002\", \"cca_003\"] \u2026 [\"seg_029\", \"seg_030\", \"seg_031\"] Number of loci: 2213 [\"Contig_35208\", \"Contig_23109\", \"Contig_4493\"] \u2026 [\"Contig_19384\", \"Contig_22368\", \"Contig_2784\"] Ploidy: 2 Number of populations: 7 #Inds | Pop -------------- 21 | 1 30 | 2 28 | 3 65 | 4 28 | 5 20 | 6 20 | 7 Available fields: ind, popid, loci, ploidy, genotypes, longitude, latitude Info While showing a PopObj represents location data as strings, they are actually coded as integers or floating point numbers. This was a design decision to remove visual clutter, however we can easily revert it back to displaying Int or Float64 with type information if that's what users prefer.","title":"Location Data"},{"location":"popobj_type/","text":"For the PopGen.jl package to be consistent, a standard flexible data structure needs to be defined. The solution is a custom type called a PopObj . The struct is defined as: mutable struct PopObj ind :: Array { String , 1 } popid :: Array { Union { Int64 , String }, 1 } loci :: Array { String , 1 } ploidy :: Int64 genotypes :: Dict longitude :: Array { Union { Int64 , Float64 }, 1 } latitude :: Array { Union { Int64 , Float64 }, 1 } end pronouncing \"PopObj\" If you haven't already guessed, PopObj is a combination of the words Population and Object. PopObj is pronounced \"pop ob\" with a silent j because it rolls of the tongue better, but writing it as PopOb looks weird. Yes, I have lost sleep over this detail. - Pavel ind type : 1-dimension array of strings ::Array{String,1} The individual/sample names [ \"ind_001\" , \"ind_002\" , \"ind_003\" ] popid type : 1-dimension array of strings ::Array{String,1} The individual/sample population ID's (in the same order) [ \"borneo\" , \"borneo\" , \"new jersey\" ] loci type : 1-dimension array of strings ::Array{String,1} The name of the loci, as an array of strings [ \"locus_001\" , \"locus_2\" , \"super-awesome-locus-3\" ] ploidy type: : Int64 The ploidy of the samples 2 genotypes type: : ::Dict of [loci] => Array{Tuple,1} The genotypes of the loci , as a dictionary of loci => genotypes. The loci are the dictionary keys keys , and the genotype values are an array of tuples , with each value corresponding to an allele. [\"locus_001\"] => [(0,1),(0,0),(1,2)] [\"locus_002\"] => [(0,0),(1,1),(2,2)] Important We use the immutable (cannot be changed) tuple type for genotypes of individuals because by the time you're using PopGen.jl , your data should already be filtered and screened. Hand-editing of genotype values is strongly discouraged, and we don't much like the idea of using this package to fudge your data that way. longitude type : one-dimensional array of integers or floating point numbers ::Array{Union{Int64,Float64},1} longitude data of samples (decimal degrees) [-11.12, 15.32, 11.02, -4] latitude type : one-dimensional array of integers or floating point numbers ::Array{Union{Int64,Float64},1} latitude data of samples (decimal degrees) [-11.12, 15.32, 11.02, -4] Viewing a PopObj Given the volume of information that can be present in a PopObj , we recommend summary() to summarize the data rather than regurgitate everything on the screen. julia> a = gulfsharks() ; julia> summary(a) Object of type PopObj: No location data provided Number of individuals: 212 [\"cca_001\", \"cca_002\", \"cca_003\"] \u2026 [\"seg_029\", \"seg_030\", \"seg_031\"] Number of loci: 2213 [\"Contig_35208\", \"Contig_23109\", \"Contig_4493\"] \u2026 [\"Contig_19384\", \"Contig_22368\", \"Contig_2784\"] Ploidy: 2 Number of populations: 7 #Inds | Pop -------------- 21 | 1 30 | 2 28 | 3 65 | 4 28 | 5 20 | 6 20 | 7 Available fields: ind, popid, loci, ploidy, genotypes, longitude, latitude For context, this is what gulfsharks looks like without a semicolon at the end \ud83e\udd2e : We chose not to define a custom Base.show method to facilitate Atom/Juno visibility and drop-downs.","title":"What's a PopObj"},{"location":"popobj_type/#ind","text":"type : 1-dimension array of strings ::Array{String,1} The individual/sample names [ \"ind_001\" , \"ind_002\" , \"ind_003\" ]","title":"ind"},{"location":"popobj_type/#popid","text":"type : 1-dimension array of strings ::Array{String,1} The individual/sample population ID's (in the same order) [ \"borneo\" , \"borneo\" , \"new jersey\" ]","title":"popid"},{"location":"popobj_type/#loci","text":"type : 1-dimension array of strings ::Array{String,1} The name of the loci, as an array of strings [ \"locus_001\" , \"locus_2\" , \"super-awesome-locus-3\" ]","title":"loci"},{"location":"popobj_type/#ploidy","text":"type: : Int64 The ploidy of the samples 2","title":"ploidy"},{"location":"popobj_type/#genotypes","text":"type: : ::Dict of [loci] => Array{Tuple,1} The genotypes of the loci , as a dictionary of loci => genotypes. The loci are the dictionary keys keys , and the genotype values are an array of tuples , with each value corresponding to an allele. [\"locus_001\"] => [(0,1),(0,0),(1,2)] [\"locus_002\"] => [(0,0),(1,1),(2,2)] Important We use the immutable (cannot be changed) tuple type for genotypes of individuals because by the time you're using PopGen.jl , your data should already be filtered and screened. Hand-editing of genotype values is strongly discouraged, and we don't much like the idea of using this package to fudge your data that way.","title":"genotypes"},{"location":"popobj_type/#longitude","text":"type : one-dimensional array of integers or floating point numbers ::Array{Union{Int64,Float64},1} longitude data of samples (decimal degrees) [-11.12, 15.32, 11.02, -4]","title":"longitude"},{"location":"popobj_type/#latitude","text":"type : one-dimensional array of integers or floating point numbers ::Array{Union{Int64,Float64},1} latitude data of samples (decimal degrees) [-11.12, 15.32, 11.02, -4]","title":"latitude"},{"location":"popobj_type/#viewing-a-popobj","text":"Given the volume of information that can be present in a PopObj , we recommend summary() to summarize the data rather than regurgitate everything on the screen. julia> a = gulfsharks() ; julia> summary(a) Object of type PopObj: No location data provided Number of individuals: 212 [\"cca_001\", \"cca_002\", \"cca_003\"] \u2026 [\"seg_029\", \"seg_030\", \"seg_031\"] Number of loci: 2213 [\"Contig_35208\", \"Contig_23109\", \"Contig_4493\"] \u2026 [\"Contig_19384\", \"Contig_22368\", \"Contig_2784\"] Ploidy: 2 Number of populations: 7 #Inds | Pop -------------- 21 | 1 30 | 2 28 | 3 65 | 4 28 | 5 20 | 6 20 | 7 Available fields: ind, popid, loci, ploidy, genotypes, longitude, latitude For context, this is what gulfsharks looks like without a semicolon at the end \ud83e\udd2e : We chose not to define a custom Base.show method to facilitate Atom/Juno visibility and drop-downs.","title":"Viewing a PopObj"},{"location":"vcf/","text":"Next on th To-Do list!","title":"VCF"}]}