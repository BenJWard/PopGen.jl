{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"This is the documentation for the PopGen.jl package. If you're reading this, you're likely interested in doing some kind of population genetics analyses. Please read through the docs and try the tutorial out to get a feel for what PopGen.jl can do. About PopGen.jl is an attempt to shift population genetics analyses away from the patchwork of available pop-gen packages present in the R and Python languages, and combine it with the speed, power, fun(?), and community of the Julia language. We hope to implement common analyses (heterozygosity, kinship, FST, Tajima's D, etc.) in sane , user friendly ways, with syntax used within the package being consistent with the rest of the Julia ecosystem. Why Julia and not Python or R? Speed and syntax The speed is comparable to C when coded correctly. Also, has Python-like syntax with optional tabs. We are also fans of 1-indexing, but that's more of a perk. A modern language for modern problems Julia has native support for: parallelization, distributed computing, GPU processing, and pipes! It also has robust machine learning packages (maybe for future implementations). Community & contribution Julia's just-in-time type-safe and optimized compiling solves what's known as the \"two language problem\". That is, languages that are easy to write in are slow, and languages that are more difficult to write in are fast. Interpreted languages, like Python, R, and Perl are easier to write in, however many of the commonly used packages and functions in those languages are written in another, faster language under the hood for performance reasons. On the whole, that's not really a problem for end-users, because functions work and they are easy to use. But , it does become a problem when you want to investigate the code and implementation of a function. This means that, even as an R power-user, you are powerless to investigate the implementation of something you are using if it's actually written in C++. In a sense, it makes the publications of those methods less reproducible, because the users of it may be familiar with the language it's deployed in (like R), but not the language it's written in, (like C++). What if there are bugs?! What if the code implementation doesn't match the formulations in the publication?! Yikes! And thus solving the two language problem, users can themselves diagnose code if they so choose. Yes, that means that we might be getting more Issues opened up, but a bug found is a lot better than a bug overlooked! Like most Julia packages, PopGen.jl is written entirely in Julia, meaning the community using it need not learn another language if they wanted to contribute! Have you written a clever Julia function to calculate SAMOVA from a PopObj ? Send us a pull request! (please!) Package manager Which is such a delight to use. Authors Pavel Dimens, PhD Student @ U. Southern Mississippi Jason Selwyn, PhD Candidate @ Texas A&M University - Corpus Christi","title":"Home"},{"location":"#about","text":"PopGen.jl is an attempt to shift population genetics analyses away from the patchwork of available pop-gen packages present in the R and Python languages, and combine it with the speed, power, fun(?), and community of the Julia language. We hope to implement common analyses (heterozygosity, kinship, FST, Tajima's D, etc.) in sane , user friendly ways, with syntax used within the package being consistent with the rest of the Julia ecosystem.","title":"About"},{"location":"#why-julia-and-not-python-or-r","text":"Speed and syntax The speed is comparable to C when coded correctly. Also, has Python-like syntax with optional tabs. We are also fans of 1-indexing, but that's more of a perk. A modern language for modern problems Julia has native support for: parallelization, distributed computing, GPU processing, and pipes! It also has robust machine learning packages (maybe for future implementations). Community & contribution Julia's just-in-time type-safe and optimized compiling solves what's known as the \"two language problem\". That is, languages that are easy to write in are slow, and languages that are more difficult to write in are fast. Interpreted languages, like Python, R, and Perl are easier to write in, however many of the commonly used packages and functions in those languages are written in another, faster language under the hood for performance reasons. On the whole, that's not really a problem for end-users, because functions work and they are easy to use. But , it does become a problem when you want to investigate the code and implementation of a function. This means that, even as an R power-user, you are powerless to investigate the implementation of something you are using if it's actually written in C++. In a sense, it makes the publications of those methods less reproducible, because the users of it may be familiar with the language it's deployed in (like R), but not the language it's written in, (like C++). What if there are bugs?! What if the code implementation doesn't match the formulations in the publication?! Yikes! And thus solving the two language problem, users can themselves diagnose code if they so choose. Yes, that means that we might be getting more Issues opened up, but a bug found is a lot better than a bug overlooked! Like most Julia packages, PopGen.jl is written entirely in Julia, meaning the community using it need not learn another language if they wanted to contribute! Have you written a clever Julia function to calculate SAMOVA from a PopObj ? Send us a pull request! (please!) Package manager Which is such a delight to use.","title":"Why Julia and not Python or R?"},{"location":"#authors","text":"Pavel Dimens, PhD Student @ U. Southern Mississippi Jason Selwyn, PhD Candidate @ Texas A&M University - Corpus Christi","title":"Authors"},{"location":"aboutdocs/","text":"Tips and hints for getting the most out of this documentation There is nothing inherently special about this documentation relative to other documentation, other than we really really want you to get the most out of what's written here. This means that we need to embrace the fact that both novice and experienced Julia users may be reading these docs and using this package. So let's cover some Julia basics that will really help in navigating this package before we even get into the complicated genetics stuff. Semicolons Semicolons will come up a lot in Julia, probably more than you would expect if you are migrating from another language. They mean different thing depending on where they are. At the end of a command When you see a semicolon after invoking a function, what that means is \"don't show me the output in the terminal window\". Example: julia > x = 2 + 2 4 julia > x = 10 + 2 ; julia > x 12 Julia will still process the command and assign 10 + 2 to x`, but it won't show you the output in the terminal. We sometimes include a semicolon after commands in these docs to mimic what the REPL output would look like without spitting back out an array of over 200 values. These semicolons are optional In between assignment commands If you see a semicolon in between two variable assignments, like so: x = [ 1 , 2 ] ; y = [ 3 , 4 ] that's a Julia short-hand for making two short lines of code appear on a single line. It's the equivalent of doing: x = [ 1 , 2 ] y = [ 3 , 4 ] We sometimes choose this writing format for very quick and small assignments hoping to save some visual space. Use whichever method is most comfortable and sensible for you! Help mode To enter help mode in the REPL, simply press the question mark key ? (shift + key) and you will notice a different prompt help?> for you to type in a function. help ?> popid search: popid popid! popfirst! popdisplay precompile __precompile__ CompositeException popid(x::PopObj; listall::Bool = false) View unique population ID's in a PopObj. listall = true, displays ind and their popid instead (default = false). Type information Julia encourages strong typing of variables, and the functions in PopGen are no exception to this. However, to reduce the barrier of entry required to understand this documentation and the subsequent package, we have chosen to omit some of the type information from functions to reduce visual clutter for newer users. As experienced users already know, if you would like to see the explicit type information, you can look at the code on github, invoke the help system in the REPL (above), or search for a function in the Documentation pane in Juno. You'll notice types follow a specific format, which is object::type . This format is a type assignment, so in the function popid , which looks like: popid(x::PopObj; listall::Bool = false) : x is a variable of type PopObj listall is a variable of type Bool (boolean) meaning it only takes true or false without quotes Type Unions You might see the type Union appear occasionally throughout this documentation, and you can consider it a list of types. For example, if something was of type ::Union{String,Integer} , that means that either a String or Integer works. These kinds of Union appear in a few places, like remove_inds! , where the input can be either a String (a single individual) or an Array{String,1} (one-dimensional list of names). For remove_inds! , the second argument type appears as ::Union{String, Array{String,1}} . Also, the order in which types appear in Union types don't matter. Functions vs. Methods As part of Julia's type-safe paradigm and multiple dispatch (see \"ERROR: MethodError: no method matching\" below), type specifications in functions often reduce runtime of functions, but also establish function identity. Multiple dispatch refers to several different functions having the same name, but employing different methods depending on the input. In Julia, it's easier to write a single function with multiple type-safe methods, rather than one mega-function that accepts any type and have a bunch of if statements that determines what the program does depending on the input. In practice, this looks like: # combine two numbers julia> function add(x::Integer, y::Integer) x+y end add (generic function with 1 method) # combine two strings julia> function add(x::String, y::String) x*y end add (generic function with 2 methods) julia> add(1,2) 3 julia> add(\"water\", \"melon\") \"watermelon\" Multiple dispatch therefor leads to a unique type of possible error: the MethodError ERROR: MethodError: no method matching Using the function add from the example above, let's have a look at what happens when we try to add an Integer with a String : julia > add ( 1 , \"melon\" ) ERROR : MethodError : no method matching add ( :: Int64 , :: String ) Closest candidates are : add ( :: String , :: String ) at none : 2 add ( :: Integer , :: Integer ) at none : 2 Stacktrace : [ 1 ] top - level scope at none : 0 This error is telling us \"there is no such function called add , who's inputs are an Integer followed by a String \". But, it does offer us some alternatives, like the two add functions we created earlier. The functions within PopGen are almost always explicitly typed, so if you are getting the MethodError: no method matching error, then you are inputting the incorrect types into the function, or perhaps your inputs for the arguments are in the wrong order (see \"Functions with and without keywords\" below). keep in mind MethodError's can definitely get annoying, but they are usually the result of incorrect input from the user and not buggy programming by the developers. Please take that into consideration before assuming something is broken or bugged. Functions with and without keywords TL;DR Reading these docs, pay attention to semicolons in the function argument lists. -- arguments before a semicolon have no keyword and follow an explicit order arguments after a semicolon have a keyword argument = value and their order doesn't matter MethodError: no methods matching is likely an issue on your side and not on our side :) unless we accidentally forgot to export a function! Broadly speaking, there are two types of function declarations in Julia: ones with keywords and ones without keywords. The term \"keywords\" refers to an input argument that has the format argument = value . This format is present in many of the functions in this and other packages, however there are some specifics to understand when functions use keywords and when they don't. Format 1: Strict argument order and no keywords - No semicolon in argument list function function_name ( var1 :: type , var2 :: type , var3 :: type ) do stuff with vars end If a function is declared with only commas in the argument list, like shown above, then the arguments to that function must have no keywords and follow the exact order they appear in. If the generic example above had the typing: function function_name ( var1 :: String , var2 :: Float64 , var3 :: Array { String , 1 }) do stuff with vars end then the only acceptable way to run this function without getting a MethodError would be with arguments in the order of function_name(String, Float64, Array{String,1}) . Even if some of the arguments have a default values, like var2::Float64 = 6.66 , the order of arguments/types has to be respected as declared. Format 2 - semicolon in argument list function function_name ( var1 :: type ; var2 :: type , var3 :: type ) do stuff with vars end In this format, everything that comes before the semicolon follows the strict rules from Format 1 , and everything that comes after the semicolon is a keyword argument. Keyword arguments have the flexibility to not require any particular input order. However, you must use the keywords to declare those arguments, or you will receive another MethodError: no method matching , which is, as we've mentioned, annoying.","title":"Docs \"Guide\""},{"location":"aboutdocs/#tips-and-hints-for-getting-the-most-out-of-this-documentation","text":"There is nothing inherently special about this documentation relative to other documentation, other than we really really want you to get the most out of what's written here. This means that we need to embrace the fact that both novice and experienced Julia users may be reading these docs and using this package. So let's cover some Julia basics that will really help in navigating this package before we even get into the complicated genetics stuff.","title":"Tips and hints for getting the most out of this documentation"},{"location":"aboutdocs/#semicolons","text":"Semicolons will come up a lot in Julia, probably more than you would expect if you are migrating from another language. They mean different thing depending on where they are.","title":"Semicolons"},{"location":"aboutdocs/#at-the-end-of-a-command","text":"When you see a semicolon after invoking a function, what that means is \"don't show me the output in the terminal window\". Example: julia > x = 2 + 2 4 julia > x = 10 + 2 ; julia > x 12 Julia will still process the command and assign 10 + 2 to x`, but it won't show you the output in the terminal. We sometimes include a semicolon after commands in these docs to mimic what the REPL output would look like without spitting back out an array of over 200 values. These semicolons are optional","title":"At the end of a command"},{"location":"aboutdocs/#in-between-assignment-commands","text":"If you see a semicolon in between two variable assignments, like so: x = [ 1 , 2 ] ; y = [ 3 , 4 ] that's a Julia short-hand for making two short lines of code appear on a single line. It's the equivalent of doing: x = [ 1 , 2 ] y = [ 3 , 4 ] We sometimes choose this writing format for very quick and small assignments hoping to save some visual space. Use whichever method is most comfortable and sensible for you!","title":"In between assignment commands"},{"location":"aboutdocs/#help-mode","text":"To enter help mode in the REPL, simply press the question mark key ? (shift + key) and you will notice a different prompt help?> for you to type in a function. help ?> popid search: popid popid! popfirst! popdisplay precompile __precompile__ CompositeException popid(x::PopObj; listall::Bool = false) View unique population ID's in a PopObj. listall = true, displays ind and their popid instead (default = false).","title":"Help mode"},{"location":"aboutdocs/#type-information","text":"Julia encourages strong typing of variables, and the functions in PopGen are no exception to this. However, to reduce the barrier of entry required to understand this documentation and the subsequent package, we have chosen to omit some of the type information from functions to reduce visual clutter for newer users. As experienced users already know, if you would like to see the explicit type information, you can look at the code on github, invoke the help system in the REPL (above), or search for a function in the Documentation pane in Juno. You'll notice types follow a specific format, which is object::type . This format is a type assignment, so in the function popid , which looks like: popid(x::PopObj; listall::Bool = false) : x is a variable of type PopObj listall is a variable of type Bool (boolean) meaning it only takes true or false without quotes","title":"Type information"},{"location":"aboutdocs/#type-unions","text":"You might see the type Union appear occasionally throughout this documentation, and you can consider it a list of types. For example, if something was of type ::Union{String,Integer} , that means that either a String or Integer works. These kinds of Union appear in a few places, like remove_inds! , where the input can be either a String (a single individual) or an Array{String,1} (one-dimensional list of names). For remove_inds! , the second argument type appears as ::Union{String, Array{String,1}} . Also, the order in which types appear in Union types don't matter.","title":"Type Unions"},{"location":"aboutdocs/#functions-vs-methods","text":"As part of Julia's type-safe paradigm and multiple dispatch (see \"ERROR: MethodError: no method matching\" below), type specifications in functions often reduce runtime of functions, but also establish function identity. Multiple dispatch refers to several different functions having the same name, but employing different methods depending on the input. In Julia, it's easier to write a single function with multiple type-safe methods, rather than one mega-function that accepts any type and have a bunch of if statements that determines what the program does depending on the input. In practice, this looks like: # combine two numbers julia> function add(x::Integer, y::Integer) x+y end add (generic function with 1 method) # combine two strings julia> function add(x::String, y::String) x*y end add (generic function with 2 methods) julia> add(1,2) 3 julia> add(\"water\", \"melon\") \"watermelon\" Multiple dispatch therefor leads to a unique type of possible error: the MethodError","title":"Functions vs. Methods"},{"location":"aboutdocs/#error-methoderror-no-method-matching","text":"Using the function add from the example above, let's have a look at what happens when we try to add an Integer with a String : julia > add ( 1 , \"melon\" ) ERROR : MethodError : no method matching add ( :: Int64 , :: String ) Closest candidates are : add ( :: String , :: String ) at none : 2 add ( :: Integer , :: Integer ) at none : 2 Stacktrace : [ 1 ] top - level scope at none : 0 This error is telling us \"there is no such function called add , who's inputs are an Integer followed by a String \". But, it does offer us some alternatives, like the two add functions we created earlier. The functions within PopGen are almost always explicitly typed, so if you are getting the MethodError: no method matching error, then you are inputting the incorrect types into the function, or perhaps your inputs for the arguments are in the wrong order (see \"Functions with and without keywords\" below). keep in mind MethodError's can definitely get annoying, but they are usually the result of incorrect input from the user and not buggy programming by the developers. Please take that into consideration before assuming something is broken or bugged.","title":"ERROR: MethodError: no method matching"},{"location":"aboutdocs/#functions-with-and-without-keywords","text":"TL;DR Reading these docs, pay attention to semicolons in the function argument lists. -- arguments before a semicolon have no keyword and follow an explicit order arguments after a semicolon have a keyword argument = value and their order doesn't matter MethodError: no methods matching is likely an issue on your side and not on our side :) unless we accidentally forgot to export a function! Broadly speaking, there are two types of function declarations in Julia: ones with keywords and ones without keywords. The term \"keywords\" refers to an input argument that has the format argument = value . This format is present in many of the functions in this and other packages, however there are some specifics to understand when functions use keywords and when they don't.","title":"Functions with and without keywords"},{"location":"aboutdocs/#format-1-strict-argument-order-and-no-keywords-no-semicolon-in-argument-list","text":"function function_name ( var1 :: type , var2 :: type , var3 :: type ) do stuff with vars end If a function is declared with only commas in the argument list, like shown above, then the arguments to that function must have no keywords and follow the exact order they appear in. If the generic example above had the typing: function function_name ( var1 :: String , var2 :: Float64 , var3 :: Array { String , 1 }) do stuff with vars end then the only acceptable way to run this function without getting a MethodError would be with arguments in the order of function_name(String, Float64, Array{String,1}) . Even if some of the arguments have a default values, like var2::Float64 = 6.66 , the order of arguments/types has to be respected as declared.","title":"Format 1: Strict argument order and no keywords - No semicolon in argument list"},{"location":"aboutdocs/#format-2-semicolon-in-argument-list","text":"function function_name ( var1 :: type ; var2 :: type , var3 :: type ) do stuff with vars end In this format, everything that comes before the semicolon follows the strict rules from Format 1 , and everything that comes after the semicolon is a keyword argument. Keyword arguments have the flexibility to not require any particular input order. However, you must use the keywords to declare those arguments, or you will receive another MethodError: no method matching , which is, as we've mentioned, annoying.","title":"Format 2 - semicolon in argument list"},{"location":"contr/","text":"Contributing We absolutely welcome contributors to this package/project! Contributing can take the form of: Optimizing available code Pointing out bugs (and troubleshooting them if possible!) Testing your data against the available code Writing new functions or methods for existing functions Spreading the word on social media Words of encouragement","title":"Contributing"},{"location":"contr/#contributing","text":"We absolutely welcome contributors to this package/project! Contributing can take the form of: Optimizing available code Pointing out bugs (and troubleshooting them if possible!) Testing your data against the available code Writing new functions or methods for existing functions Spreading the word on social media Words of encouragement","title":"Contributing"},{"location":"editing/","text":"Editing PopObj elements Following standard Julia convention, functions ending with ! are mutable, meaning they will edit the input. To follow along, load in the provided test data in /test/testdata.gen using PopGen a = genepop ( \"/test/testdata.gen\" , numpops = 7 ) Keep in mind, your path to that file is probably different. If using windows make sure to change your backslashes \"\\\" to forward slashes \"/\" add location data Location data can be added by directly accessing the fields .longitude and .latitude in your PopObj a . longitude = rand ( 1 : 50 , 212 ) # creates 212 unique random numbers between 1 and 50 a . latitdue = rand ( 20 : 30 , 212 ) # creates 212 unique random numbers between 20 and 30 However, if your data is in decimal minutes rather than decimal degrees, use the locations! function to add it to the fields. This function will do a conversion for you. adding decimal minutes data locations! ( x :: PopObj ; xloc :: Array , yloc :: Array ) Adds location data (longitude, latitude) to PopObj . Takes decimal degrees or decimal minutes format. Must use minus-sign instead of cardinal directions (i.e. 14 32.11W is not vaild). Location data must be in order of individuals ( ind ). Replaces existing PopObj location data. Decimal Degrees : -11.431 Decimal Minutes : \"-11 43.11\" (must use space and double-quotes) If conversion is not necessary, can directly assign PopObj.longitude and PopObj.latitude as shown above. rename populations popid! ( x :: PopObj ; rename :: Dict ) Rename the population ID's of PopObj.popid . Uses a Dict of [popid] => replacement to rename Example: # create a dictionary of name conversions new_popnames = Dict ( 1 => \"Cape Canaveral\" , 2 => \"Georgia\" , 3 => \"S Carolina\" , 4 => \"FL Keys\" , 5 => \"Mideast Gulf\" , 6 => \"Northeast Gulf\" , 7 => \"Southeast Gulf\" ) popid! ( x , rename = new_popnames ) remove loci remove_loci! ( x :: PopObj , loci :: Union { String , Array { String , 1 }}) Removes selected loci from a PopObj . Examples: remove_loci! ( a , \"contig_35208\" ) remove_loci! ( a , [ \"contig_35208\" , \"contig_23109\" , \"contig_4493\" ]) remove individuals remove_inds! ( x :: PopObj , inds :: Union { Array { String , 1 }}) Removes selected individuals from a PopObj . Examples: remove_inds! ( a , \"cca_001\" ) remove_inds ( a , [ \"cca_001\" , \"cca_002\" , \"cca_003\" ])","title":"Editing PopObj"},{"location":"editing/#editing-popobj-elements","text":"Following standard Julia convention, functions ending with ! are mutable, meaning they will edit the input. To follow along, load in the provided test data in /test/testdata.gen using PopGen a = genepop ( \"/test/testdata.gen\" , numpops = 7 ) Keep in mind, your path to that file is probably different. If using windows make sure to change your backslashes \"\\\" to forward slashes \"/\"","title":"Editing PopObj elements"},{"location":"editing/#add-location-data","text":"Location data can be added by directly accessing the fields .longitude and .latitude in your PopObj a . longitude = rand ( 1 : 50 , 212 ) # creates 212 unique random numbers between 1 and 50 a . latitdue = rand ( 20 : 30 , 212 ) # creates 212 unique random numbers between 20 and 30 However, if your data is in decimal minutes rather than decimal degrees, use the locations! function to add it to the fields. This function will do a conversion for you.","title":"add location data"},{"location":"editing/#adding-decimal-minutes-data","text":"locations! ( x :: PopObj ; xloc :: Array , yloc :: Array ) Adds location data (longitude, latitude) to PopObj . Takes decimal degrees or decimal minutes format. Must use minus-sign instead of cardinal directions (i.e. 14 32.11W is not vaild). Location data must be in order of individuals ( ind ). Replaces existing PopObj location data. Decimal Degrees : -11.431 Decimal Minutes : \"-11 43.11\" (must use space and double-quotes) If conversion is not necessary, can directly assign PopObj.longitude and PopObj.latitude as shown above.","title":"adding decimal minutes data"},{"location":"editing/#rename-populations","text":"popid! ( x :: PopObj ; rename :: Dict ) Rename the population ID's of PopObj.popid . Uses a Dict of [popid] => replacement to rename Example: # create a dictionary of name conversions new_popnames = Dict ( 1 => \"Cape Canaveral\" , 2 => \"Georgia\" , 3 => \"S Carolina\" , 4 => \"FL Keys\" , 5 => \"Mideast Gulf\" , 6 => \"Northeast Gulf\" , 7 => \"Southeast Gulf\" ) popid! ( x , rename = new_popnames )","title":"rename populations"},{"location":"editing/#remove-loci","text":"remove_loci! ( x :: PopObj , loci :: Union { String , Array { String , 1 }}) Removes selected loci from a PopObj . Examples: remove_loci! ( a , \"contig_35208\" ) remove_loci! ( a , [ \"contig_35208\" , \"contig_23109\" , \"contig_4493\" ])","title":"remove loci"},{"location":"editing/#remove-individuals","text":"remove_inds! ( x :: PopObj , inds :: Union { Array { String , 1 }}) Removes selected individuals from a PopObj . Examples: remove_inds! ( a , \"cca_001\" ) remove_inds ( a , [ \"cca_001\" , \"cca_002\" , \"cca_003\" ])","title":"remove individuals"},{"location":"importing/","text":"Importing Data At present, PopGen.jl has two file importers: one for CSV (or other delimited) files and another for genepop formatted files. CSV Loci names must be first row Individuals names must be first value in row Population ID's must be second value in row Optional: longitude (x) values third value in row, latitude (y) fourth Formatting examples without locations Locus1,Locus2,Locus3 sierra_01,1,001001,002002,001001 sierra_02,1,001001,001001,001002 snbarb_03,2,001001,001001,001002 snbarb_02,2,001001,001001,001001 snbarb_03,2,001002,001001,001001 with locations Locus1,Locus2,Locus3 sierra_01,1,14.1,15.2,001001,002002,001001 sierra_02,1,34.1,26.1,001001,001001,001002 snbarb_03,2,45.1,-11.2,001001,001001,001002 snbarb_02,2,-11.5,11.6,001001,001001,001001 snbarb_03,2,-3.1,43.2,001002,001001,001001 To import a CSV into Julia as a PopObj : csv ( infile ; delim , ploidy = 2 , location = false ) # Example a = csv ( \"/data/cali_poppy.csv\" , delim = \",\" , ploidy = 2 ) Arguments: infile::String : path to the input file, in quotes Keyword Arguments: delim::Union{Char,String,Regex} : delimiter of the file, can be a string, character, or regex comma: delim = \",\" space: delim = \" \" tab: delim = \"\\t\" etc. ploidy::Int64 : single integer of the ploidy of the samples in the file (default = 2) haploid: ploidy = 1 diploid: ploidy = 2 triploid: ploidy = 3 etc. location::Bool = false : true/false of whether location data is present in the file (default = false) Genepop Files must follow standard Genepop formatting: First line is a comment (and skipped) Loci are listed after first line as one-per-line without commas or in single comma-separated row A line with a particular keyword must delimit populations Must be the same word each time and not a unique population name File is tab or space delimted Formatting Examples loci stacked vertically Wasp populations in New York Locus1 Locus2 Locus3 POP Oneida_01, 250230 564568 110100 Oneida_02, 252238 568558 100120 Oneida_03, 254230 564558 090100 POP Newcomb_01, 254230 564558 080100 Newcomb_02, 000230 564558 090080 Newcomb_03, 254230 000000 090100 Newcomb_04, 254230 564000 090120 loci stacked horizontally Wasp populations in New York Locus1,Locus2,Locus3 POP Oneida_01, 250230 564568 110100 Oneida_02, 252238 568558 100120 Oneida_03, 254230 564558 090100 POP Newcomb_01, 254230 564558 080100 Newcomb_02, 000230 564558 090080 Newcomb_03, 254230 000000 090100 Newcomb_04, 254230 564000 090120 To import a genepop file into Julia as a PopObj : genepop ( infile ; ploidy = 2 , popsep = \"POP\" , numpop ) # Example b = genepop ( \"/data/wasp_hive.gen\" , ploidy = 2 , popsep = \"POP\" , numpops = 2 ) Arguments: infile::String : path to genepop file, in quotes Keyword Arguments: ploidy::Int64 : single integer of the ploidy of the samples in the file (default = 2) haploid: ploidy = 1 diploid: ploidy = 2 triploid: ploidy = 3 etc. popsep::String : word that separates populations in infile (default: \"POP\") numpops::Int64 : number of populations present in infile (used for early error checking) Note By default, the file reader will assign numbers as population ID's in order of appearance in the genepop file. Use the popid! function to rename these with your own population ID's. VCF On the To-Do list!","title":"Importing Data"},{"location":"importing/#importing-data","text":"At present, PopGen.jl has two file importers: one for CSV (or other delimited) files and another for genepop formatted files.","title":"Importing Data"},{"location":"importing/#csv","text":"Loci names must be first row Individuals names must be first value in row Population ID's must be second value in row Optional: longitude (x) values third value in row, latitude (y) fourth Formatting examples without locations Locus1,Locus2,Locus3 sierra_01,1,001001,002002,001001 sierra_02,1,001001,001001,001002 snbarb_03,2,001001,001001,001002 snbarb_02,2,001001,001001,001001 snbarb_03,2,001002,001001,001001 with locations Locus1,Locus2,Locus3 sierra_01,1,14.1,15.2,001001,002002,001001 sierra_02,1,34.1,26.1,001001,001001,001002 snbarb_03,2,45.1,-11.2,001001,001001,001002 snbarb_02,2,-11.5,11.6,001001,001001,001001 snbarb_03,2,-3.1,43.2,001002,001001,001001 To import a CSV into Julia as a PopObj : csv ( infile ; delim , ploidy = 2 , location = false ) # Example a = csv ( \"/data/cali_poppy.csv\" , delim = \",\" , ploidy = 2 ) Arguments: infile::String : path to the input file, in quotes Keyword Arguments: delim::Union{Char,String,Regex} : delimiter of the file, can be a string, character, or regex comma: delim = \",\" space: delim = \" \" tab: delim = \"\\t\" etc. ploidy::Int64 : single integer of the ploidy of the samples in the file (default = 2) haploid: ploidy = 1 diploid: ploidy = 2 triploid: ploidy = 3 etc. location::Bool = false : true/false of whether location data is present in the file (default = false)","title":"CSV"},{"location":"importing/#genepop","text":"Files must follow standard Genepop formatting: First line is a comment (and skipped) Loci are listed after first line as one-per-line without commas or in single comma-separated row A line with a particular keyword must delimit populations Must be the same word each time and not a unique population name File is tab or space delimted Formatting Examples loci stacked vertically Wasp populations in New York Locus1 Locus2 Locus3 POP Oneida_01, 250230 564568 110100 Oneida_02, 252238 568558 100120 Oneida_03, 254230 564558 090100 POP Newcomb_01, 254230 564558 080100 Newcomb_02, 000230 564558 090080 Newcomb_03, 254230 000000 090100 Newcomb_04, 254230 564000 090120 loci stacked horizontally Wasp populations in New York Locus1,Locus2,Locus3 POP Oneida_01, 250230 564568 110100 Oneida_02, 252238 568558 100120 Oneida_03, 254230 564558 090100 POP Newcomb_01, 254230 564558 080100 Newcomb_02, 000230 564558 090080 Newcomb_03, 254230 000000 090100 Newcomb_04, 254230 564000 090120 To import a genepop file into Julia as a PopObj : genepop ( infile ; ploidy = 2 , popsep = \"POP\" , numpop ) # Example b = genepop ( \"/data/wasp_hive.gen\" , ploidy = 2 , popsep = \"POP\" , numpops = 2 ) Arguments: infile::String : path to genepop file, in quotes Keyword Arguments: ploidy::Int64 : single integer of the ploidy of the samples in the file (default = 2) haploid: ploidy = 1 diploid: ploidy = 2 triploid: ploidy = 3 etc. popsep::String : word that separates populations in infile (default: \"POP\") numpops::Int64 : number of populations present in infile (used for early error checking) Note By default, the file reader will assign numbers as population ID's in order of appearance in the genepop file. Use the popid! function to rename these with your own population ID's.","title":"Genepop"},{"location":"importing/#vcf","text":"On the To-Do list!","title":"VCF"},{"location":"install/","text":"Installation Installing PopGen.jl The package is currently unregistered while it's under active early development. However, installation is still simple! Invoke the package manager with ] in the REPL and use add \"https://github.com/pdimens/PopGen.jl\" after the package is installed, load it with using PopGen If using Jupyter Notebooks or nteract, install the package in julia with using Pkg Pkg . add ( \"https://github.com/pdimens/PopGen.jl\" ) Feel free to play around with the test data in /test/testdata.gen Using PopGen Like all Julia packages, to activate PopGen , simply run: using PopGen Performance notes If you're migrating to Julia from Python or R (or Matlab, etc.), you'll think Julia is slow and laggy because loading packages and running stuff has a noticeable wait time (10-40sec). However, if this is your first time in Julia, then it's worth mentioning that this lag is \"compilation overhead\". What this means is, Julia tries to pre-compile as much code as possible (into optimized machine code) when running something or loading a package. This lag exists only the first time you run something. Every subsequent run of a function, even with different parameters, will be substantially faster, and in most cases instant. If you want to test this yourself, try to run a line of code twice with @time before the function and compare the results. Here's an example: julia > @time using PopGen 17.415902 seconds (19.88 M allocations: 1.022 GiB, 2.79% gc time) julia > @time using PopGen 0.100233 seconds (64.07 k allocations: 3.123 MiB, 6.02% gc time)","title":"Installing"},{"location":"install/#installation","text":"","title":"Installation"},{"location":"install/#installing-popgenjl","text":"The package is currently unregistered while it's under active early development. However, installation is still simple! Invoke the package manager with ] in the REPL and use add \"https://github.com/pdimens/PopGen.jl\" after the package is installed, load it with using PopGen If using Jupyter Notebooks or nteract, install the package in julia with using Pkg Pkg . add ( \"https://github.com/pdimens/PopGen.jl\" ) Feel free to play around with the test data in /test/testdata.gen","title":"Installing PopGen.jl"},{"location":"install/#using-popgen","text":"Like all Julia packages, to activate PopGen , simply run: using PopGen Performance notes If you're migrating to Julia from Python or R (or Matlab, etc.), you'll think Julia is slow and laggy because loading packages and running stuff has a noticeable wait time (10-40sec). However, if this is your first time in Julia, then it's worth mentioning that this lag is \"compilation overhead\". What this means is, Julia tries to pre-compile as much code as possible (into optimized machine code) when running something or loading a package. This lag exists only the first time you run something. Every subsequent run of a function, even with different parameters, will be substantially faster, and in most cases instant. If you want to test this yourself, try to run a line of code twice with @time before the function and compare the results. Here's an example: julia > @time using PopGen 17.415902 seconds (19.88 M allocations: 1.022 GiB, 2.79% gc time) julia > @time using PopGen 0.100233 seconds (64.07 k allocations: 3.123 MiB, 6.02% gc time)","title":"Using PopGen"},{"location":"plotting/","text":"Plotting The output of many functions are formatted for use in your favorite Julia plotting environments, such as Plots , Makie , PlotlyJS , PyPlot , Gadfly , etc. However, some convenience plots are provided to assist with speedy data visualization and exploration. plot missing data plot_missing ( x :: PopObj ; color = false ) Return an interactive plot of the number of missing loci in individuals of a PopObj , along with the number of missing individuals per locus. To set a custom color palette, use color = [color1, color2, ...] Example: julia > plot_missing ( a ) If you would like to save the interactive plot as a local HTML file (does not require Plotly account): using PlotlyJS PlotlyJS . savehtml ( plot_missing ( a ), \"filename.html\" ) This will save it in the current working directly as whatever you replace filename.html with. If you want the file to work properly offline, add a third option argument :embed , although be aware it inflates the file size (~3.5mb for the test data). plot sample locations plot_locations(x::PopObj; region = \"world\", projection = \"orthographic\") Returns a simple lower resolution interactive scatterplot of the individuals in a PopObj . Default region and projection are \"world\" and \"orthographic\", respectively. If a specific region is set, the plot will default to \"mercator\" projection unless projection = is used to specify a different one. Example: julia > a . latitude = rand ( 10 : 30 , 212 ); a . longitude = rand ( - 99 :- 80 , 212 ) ; julia > plot_locations ( a ) julia > plot_locations ( a , region = \"north america\" , projection = \"mercator\" ) ` regions usa europe asia africa north america south america projections equirectangular mercator orthographic natural earth kavrayskiy7 miller robinson eckert4 azimuthal equal area azimuthal equidistant conic equal area conic conformal conic equidistant gnomonic stereographic mollweide hammer transverse mercator albers usa winkel tripel aitoff sinusoidal Saving As before, you can save the plot to an HTML file: using PlotlyJS PlotlyJS . savehtml ( plot_locations ( a , region = \"north america\" , projection = \"mercator\" ), \"filename.html\" )","title":"Plotting"},{"location":"plotting/#plotting","text":"The output of many functions are formatted for use in your favorite Julia plotting environments, such as Plots , Makie , PlotlyJS , PyPlot , Gadfly , etc. However, some convenience plots are provided to assist with speedy data visualization and exploration.","title":"Plotting"},{"location":"plotting/#plot-missing-data","text":"plot_missing ( x :: PopObj ; color = false ) Return an interactive plot of the number of missing loci in individuals of a PopObj , along with the number of missing individuals per locus. To set a custom color palette, use color = [color1, color2, ...] Example: julia > plot_missing ( a ) If you would like to save the interactive plot as a local HTML file (does not require Plotly account): using PlotlyJS PlotlyJS . savehtml ( plot_missing ( a ), \"filename.html\" ) This will save it in the current working directly as whatever you replace filename.html with. If you want the file to work properly offline, add a third option argument :embed , although be aware it inflates the file size (~3.5mb for the test data).","title":"plot missing data"},{"location":"plotting/#plot-sample-locations","text":"plot_locations(x::PopObj; region = \"world\", projection = \"orthographic\") Returns a simple lower resolution interactive scatterplot of the individuals in a PopObj . Default region and projection are \"world\" and \"orthographic\", respectively. If a specific region is set, the plot will default to \"mercator\" projection unless projection = is used to specify a different one. Example: julia > a . latitude = rand ( 10 : 30 , 212 ); a . longitude = rand ( - 99 :- 80 , 212 ) ; julia > plot_locations ( a ) julia > plot_locations ( a , region = \"north america\" , projection = \"mercator\" ) ` regions usa europe asia africa north america south america projections equirectangular mercator orthographic natural earth kavrayskiy7 miller robinson eckert4 azimuthal equal area azimuthal equidistant conic equal area conic conformal conic equidistant gnomonic stereographic mollweide hammer transverse mercator albers usa winkel tripel aitoff sinusoidal Saving As before, you can save the plot to an HTML file: using PlotlyJS PlotlyJS . savehtml ( plot_locations ( a , region = \"north america\" , projection = \"mercator\" ), \"filename.html\" )","title":"plot sample locations"},{"location":"popobj/","text":"the PopObj type What is a PopObj For the PopGen.jl package to be consistent, a standard flexible data structure needs to be defined. The solution is a custom type called a PopObj (pronounced \"pop ob\" with a silent j because it rolls of the tongue better). If you haven't already guessed, it's a combination of the words Population and Object. The struct is defined as: mutable struct PopObj ind :: Array { String , 1 } popid :: Array { Union { Int64 , String }, 1 } loci :: Array { String , 1 } ploidy :: Int64 genotypes :: Dict longitude :: Array { Union { Int64 , Float64 }, 1 } latitude :: Array { Union { Int64 , Float64 }, 1 } end ind : the individual/sample names popid : the individual/sample population ID's (in the same order) loci : the name of the loci ploidy : the ploidy of the samples genotypes : the genotypes of the loci longitude : longitude data of samples (decimal degrees) latitude : latitude data of samples (decimal degrees) Accessing any of these fields is done with a dot . accessor and can use the [] slice accessor, as per standard Julia convention: julia> a = genepop(\"/test/testdata.gen\", numpops = 7) ; julia> a.ind[1:6] 6-element Array{String,1}: \"cca_001\" \"cca_002\" \"cca_003\" \"cca_005\" \"cca_007\" \"cca_008\" julia> a.loci[1:6] 6-element Array{String,1}: \"Contig_35208\" \"Contig_23109\" \"Contig_4493\" \"Contig_10742\" \"Contig_14898\" \"Contig_8483\" julia> a.ploidy 2 Given the volume of information that can be present in a PopObj , we defined a custom Base.show(::PopObj) to summarize the data rather than regurgitate everything on the screen. julia> a Object of type PopObj: No location data provided Number of individuals: 212 [\"cca_001\", \"cca_002\", \"cca_003\"] \u2026 [\"seg_029\", \"seg_030\", \"seg_031\"] Number of loci: 2213 [\"Contig_35208\", \"Contig_23109\", \"Contig_4493\"] \u2026 [\"Contig_19384\", \"Contig_22368\", \"Contig_2784\"] Ploidy: 2 Number of populations: 7 #Inds | Pop -------------- 21 | 1 30 | 2 28 | 3 65 | 4 28 | 5 20 | 6 20 | 7 Available fields: ind, popid, loci, ploidy, genotypes, longitude, latitude Location Data Notice the No location data provided text on the second line of output above. That text exists as a \"heads up\" rather than a warning because location data is optional for a PopObj . There are functions that use location information (e.g. locations and plot_locations ), but most don't, so it's not a dealbreaker. If you add location information, displaying the PopObj again will show you output now including this information: julia> a.latitude = rand(1:50, 212) ; a.longitude = rand(1:50, 212) ; # assign random location data julia> a Object of type PopObj: Longitude: [\"26\", \"7\", \"21\"] \u2026 [\"25\", \"26\", \"29\"] Latitude: [\"10\", \"10\", \"40\"] \u2026 [\"3\", \"5\", \"46\"] Number of individuals: 212 [\"cca_001\", \"cca_002\", \"cca_003\"] \u2026 [\"seg_029\", \"seg_030\", \"seg_031\"] Number of loci: 2213 [\"Contig_35208\", \"Contig_23109\", \"Contig_4493\"] \u2026 [\"Contig_19384\", \"Contig_22368\", \"Contig_2784\"] Ploidy: 2 Number of populations: 7 #Inds | Pop -------------- 21 | 1 30 | 2 28 | 3 65 | 4 28 | 5 20 | 6 20 | 7 Available fields: ind, popid, loci, ploidy, genotypes, longitude, latitude","title":"The PopObj"},{"location":"popobj/#the-popobj-type","text":"","title":"the PopObj type"},{"location":"popobj/#what-is-a-popobj","text":"For the PopGen.jl package to be consistent, a standard flexible data structure needs to be defined. The solution is a custom type called a PopObj (pronounced \"pop ob\" with a silent j because it rolls of the tongue better). If you haven't already guessed, it's a combination of the words Population and Object. The struct is defined as: mutable struct PopObj ind :: Array { String , 1 } popid :: Array { Union { Int64 , String }, 1 } loci :: Array { String , 1 } ploidy :: Int64 genotypes :: Dict longitude :: Array { Union { Int64 , Float64 }, 1 } latitude :: Array { Union { Int64 , Float64 }, 1 } end ind : the individual/sample names popid : the individual/sample population ID's (in the same order) loci : the name of the loci ploidy : the ploidy of the samples genotypes : the genotypes of the loci longitude : longitude data of samples (decimal degrees) latitude : latitude data of samples (decimal degrees) Accessing any of these fields is done with a dot . accessor and can use the [] slice accessor, as per standard Julia convention: julia> a = genepop(\"/test/testdata.gen\", numpops = 7) ; julia> a.ind[1:6] 6-element Array{String,1}: \"cca_001\" \"cca_002\" \"cca_003\" \"cca_005\" \"cca_007\" \"cca_008\" julia> a.loci[1:6] 6-element Array{String,1}: \"Contig_35208\" \"Contig_23109\" \"Contig_4493\" \"Contig_10742\" \"Contig_14898\" \"Contig_8483\" julia> a.ploidy 2 Given the volume of information that can be present in a PopObj , we defined a custom Base.show(::PopObj) to summarize the data rather than regurgitate everything on the screen. julia> a Object of type PopObj: No location data provided Number of individuals: 212 [\"cca_001\", \"cca_002\", \"cca_003\"] \u2026 [\"seg_029\", \"seg_030\", \"seg_031\"] Number of loci: 2213 [\"Contig_35208\", \"Contig_23109\", \"Contig_4493\"] \u2026 [\"Contig_19384\", \"Contig_22368\", \"Contig_2784\"] Ploidy: 2 Number of populations: 7 #Inds | Pop -------------- 21 | 1 30 | 2 28 | 3 65 | 4 28 | 5 20 | 6 20 | 7 Available fields: ind, popid, loci, ploidy, genotypes, longitude, latitude","title":"What is a PopObj"},{"location":"popobj/#location-data","text":"Notice the No location data provided text on the second line of output above. That text exists as a \"heads up\" rather than a warning because location data is optional for a PopObj . There are functions that use location information (e.g. locations and plot_locations ), but most don't, so it's not a dealbreaker. If you add location information, displaying the PopObj again will show you output now including this information: julia> a.latitude = rand(1:50, 212) ; a.longitude = rand(1:50, 212) ; # assign random location data julia> a Object of type PopObj: Longitude: [\"26\", \"7\", \"21\"] \u2026 [\"25\", \"26\", \"29\"] Latitude: [\"10\", \"10\", \"40\"] \u2026 [\"3\", \"5\", \"46\"] Number of individuals: 212 [\"cca_001\", \"cca_002\", \"cca_003\"] \u2026 [\"seg_029\", \"seg_030\", \"seg_031\"] Number of loci: 2213 [\"Contig_35208\", \"Contig_23109\", \"Contig_4493\"] \u2026 [\"Contig_19384\", \"Contig_22368\", \"Contig_2784\"] Ploidy: 2 Number of populations: 7 #Inds | Pop -------------- 21 | 1 30 | 2 28 | 3 65 | 4 28 | 5 20 | 6 20 | 7 Available fields: ind, popid, loci, ploidy, genotypes, longitude, latitude","title":"Location Data"},{"location":"viewing/","text":"Viewing elements in a PopObj A handful of convenience functions exist for viewing data. To follow along, load in the provided test data in /test/testdata.gen using PopGen a = genepop ( \"/test/testdata.gen\" , numpops = 7 ) Keep in mind, your path to that file is probably different. If using windows make sure to change your backslashes \"\\\" to forward slashes \"/\" individual/sample names indnames ( x :: PopObj ) View individual/sample names in a PopObj . This is equivalent to PopObj.ind Example: indnames ( a ) loci loci ( x :: PopObj , loci = nothing ) View the genotypes of all individuals for specific loci in a PopObj . Default shows all genotypes for all individuals. Use loci = to specify a single locus or array of loci to display. Examples: all loci loci ( a ) single locus loci ( a , \"contig_35208\" ) multiple loci loci ( a , [ \"contig_35208\" , \"contig_23109\" , \"contig_4493\" ]) locations locations ( x :: PopObj ) View location data ( .longitude and .latitude ) in a PopObj Example: locations ( a ) Use locations! to add spatial data to a PopObj population ID's popid ( x :: PopObj ; listall :: Bool = false ) View unique population ID's in a PopObj . Default ( listall = false ) shows basic summary table of unique populations and the number of individuals in them. Use listall = true to display all individuals ( ind ) and their popid instead. Examples: summary of unique pops popid ( a ) every individual's population ID popid ( a , listall = true ) Info Use popid! to change the names of the populations genotypes genotypes ( x :: PopObj ; inds = nothing ) Show all the genotypes of specific individuals within a PopObj . Default is to show all individuals so use inds = to specify individuals. Names must be in quotes Examples: all individuals genotypes ( a ) single individual genotypes ( a , inds = \"cca_001\" ) multiple individuals genotypes ( a , inds = [ \"cca_001\" , \"cca_002\" , \"cca_003\" ]) find missing missing ( x :: PopObj ) Identify and count missing loci in each individual of a PopObj . Returns a tuple of two DataFrames : loci per individual, number per loci. Example: missing ( a ) miss_ind , miss_loci = missing ( a ) Info since missing outputs a tuple of 2 DataFrames, so you can also assign two variables simultaneously to inherit the values of these dataframes, as with the second example.","title":"Viewing Data"},{"location":"viewing/#viewing-elements-in-a-popobj","text":"A handful of convenience functions exist for viewing data. To follow along, load in the provided test data in /test/testdata.gen using PopGen a = genepop ( \"/test/testdata.gen\" , numpops = 7 ) Keep in mind, your path to that file is probably different. If using windows make sure to change your backslashes \"\\\" to forward slashes \"/\"","title":"Viewing elements in a PopObj"},{"location":"viewing/#individualsample-names","text":"indnames ( x :: PopObj ) View individual/sample names in a PopObj . This is equivalent to PopObj.ind Example: indnames ( a )","title":"individual/sample names"},{"location":"viewing/#loci","text":"loci ( x :: PopObj , loci = nothing ) View the genotypes of all individuals for specific loci in a PopObj . Default shows all genotypes for all individuals. Use loci = to specify a single locus or array of loci to display. Examples: all loci loci ( a ) single locus loci ( a , \"contig_35208\" ) multiple loci loci ( a , [ \"contig_35208\" , \"contig_23109\" , \"contig_4493\" ])","title":"loci"},{"location":"viewing/#locations","text":"locations ( x :: PopObj ) View location data ( .longitude and .latitude ) in a PopObj Example: locations ( a ) Use locations! to add spatial data to a PopObj","title":"locations"},{"location":"viewing/#population-ids","text":"popid ( x :: PopObj ; listall :: Bool = false ) View unique population ID's in a PopObj . Default ( listall = false ) shows basic summary table of unique populations and the number of individuals in them. Use listall = true to display all individuals ( ind ) and their popid instead. Examples: summary of unique pops popid ( a ) every individual's population ID popid ( a , listall = true ) Info Use popid! to change the names of the populations","title":"population ID's"},{"location":"viewing/#genotypes","text":"genotypes ( x :: PopObj ; inds = nothing ) Show all the genotypes of specific individuals within a PopObj . Default is to show all individuals so use inds = to specify individuals. Names must be in quotes Examples: all individuals genotypes ( a ) single individual genotypes ( a , inds = \"cca_001\" ) multiple individuals genotypes ( a , inds = [ \"cca_001\" , \"cca_002\" , \"cca_003\" ])","title":"genotypes"},{"location":"viewing/#find-missing","text":"missing ( x :: PopObj ) Identify and count missing loci in each individual of a PopObj . Returns a tuple of two DataFrames : loci per individual, number per loci. Example: missing ( a ) miss_ind , miss_loci = missing ( a ) Info since missing outputs a tuple of 2 DataFrames, so you can also assign two variables simultaneously to inherit the values of these dataframes, as with the second example.","title":"find missing"}]}