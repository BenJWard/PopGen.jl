{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"This is the documentation for the PopGen.jl package. If you're reading this, you're likely interested in doing some kind of population genetics analyses. Please read through the docs and try the functions out with the test data in /test/testdata.gen to get a feel for what PopGen.jl can do. About PopGen.jl is an attempt to shift population genetics analyses away from the patchwork of available pop-gen packages present in the R and Python languages, and combine it with the speed, power, fun(?), and community of the Julia language. We hope to implement common analyses (heterozygosity, kinship, FST, Tajima's D, etc.) in sane , user friendly ways, with syntax used within the package being consistent with the rest of the Julia ecosystem. Goal To be a comprehensive package for population genetics analyses and visualization that's fast and user friendly. This project is developed with a particular mantra: Sanity, Sensibility, Accessibility . Sanity Functions are written in a way such that their use is sane and natural. When possible (or sensible), we use full words for input variables or other components of input/output. All functions in this package have their first argument as the input data without keywords. Always. We also try to minimize redundancy, such as the function remove_loci! , where the loci you wish you remove are listed as the second argument without a keyword, because the name of the function is already self explanatory, and the first argument will always be the input data, therefor having a keyword argument loci = would be redundant. Sensibility Functions need to be sensible, both in what they do and how they do it. This means that functions should include only the most relevant arguments, and the most sensible defaults for arguments. It also means the outputs need to be flexible enough to use with other Julia packages. As an example, plot_missing takes the entire PopObj as an argument rather than a user specifying specific elements, and it returns a pre-configured plot for basic data visualization. The only arguments are a custom color palette, if so desired. However, the purpose of that plot is for data exploration, so the specification of plotting attributes is unnecessary because those plots will never be in publications. If a user wants to make their own plots using that information, they can do that with the dataframes produced from missing , which is exactly what plot_missing does under the hood! Accessibility Documentation is everything! We recognize Julia is a comparatively young language, and we know which languages and packages other population geneticists are using for their work. We want you to be comfortable using PopGen.jl , and that means investing a lot of time into writing thorough documentation intended for users (vs developers). We also recognize that you (the reader) might not be very familiar with Julia, or any language other than R (which is ok!), so we've written a section on clarifying some Julia concepts/conventions that will make reading this documentation a whole lot clearer. It is by no means a replacement for sitting down and learning the Julia language a bit ( here is a great online book on that ), but it should hopefully reduce the barrier of entry somewhat. Why Julia and not Python or R? Speed and syntax The speed is comparable to C when coded correctly. Also, has Python-like syntax with optional tabs. We are also fans of 1-indexing, but that's more of a perk. A modern language for modern problems Julia has native support for: parallelization, distributed computing, GPU processing, and pipes! It also has robust machine learning packages (maybe for future implementations). Community & contribution Julia's just-in-time type-safe and optimized compiling solves what's known as the \"two language problem\". That is, languages that are easy to write in are slow, and languages that are more difficult to write in are fast. Interpreted languages, like Python, R, and Perl are easier to write in, however many of the commonly used packages and functions in those languages are written in another, faster language under the hood for performance reasons. On the whole, that's not really a problem for end-users, because functions work and they are easy to use. But , it does become a problem when you want to investigate the code and implementation of a function. This means that, even as an R power-user, you are powerless to investigate the implementation of something you are using if it's actually written in C++. In a sense, it makes the publications of those methods less reproducible, because the users of it may be familiar with the language it's deployed in (like R), but not the language it's written in, (like C++). What if there are bugs?! What if the code implementation doesn't match the formulations in the publication?! Yikes! And thus solving the two language problem, users can themselves diagnose code if they so choose. Yes, that means that we might be getting more Issues opened up, but a bug found is a lot better than a bug overlooked! Like most Julia packages, PopGen.jl is written entirely in Julia, meaning the community using it need not learn another language if they wanted to contribute! Have you written a clever Julia function to calculate SAMOVA from a PopObj ? Send us a pull request! (please!) Package manager Which is such a delight to use. Authors Pavel Dimens, PhD Student @ U. Southern Mississippi Jason Selwyn, PhD Candidate @ Texas A&M University - Corpus Christi","title":"Home"},{"location":"#about","text":"PopGen.jl is an attempt to shift population genetics analyses away from the patchwork of available pop-gen packages present in the R and Python languages, and combine it with the speed, power, fun(?), and community of the Julia language. We hope to implement common analyses (heterozygosity, kinship, FST, Tajima's D, etc.) in sane , user friendly ways, with syntax used within the package being consistent with the rest of the Julia ecosystem.","title":"About"},{"location":"#goal","text":"To be a comprehensive package for population genetics analyses and visualization that's fast and user friendly. This project is developed with a particular mantra: Sanity, Sensibility, Accessibility . Sanity Functions are written in a way such that their use is sane and natural. When possible (or sensible), we use full words for input variables or other components of input/output. All functions in this package have their first argument as the input data without keywords. Always. We also try to minimize redundancy, such as the function remove_loci! , where the loci you wish you remove are listed as the second argument without a keyword, because the name of the function is already self explanatory, and the first argument will always be the input data, therefor having a keyword argument loci = would be redundant. Sensibility Functions need to be sensible, both in what they do and how they do it. This means that functions should include only the most relevant arguments, and the most sensible defaults for arguments. It also means the outputs need to be flexible enough to use with other Julia packages. As an example, plot_missing takes the entire PopObj as an argument rather than a user specifying specific elements, and it returns a pre-configured plot for basic data visualization. The only arguments are a custom color palette, if so desired. However, the purpose of that plot is for data exploration, so the specification of plotting attributes is unnecessary because those plots will never be in publications. If a user wants to make their own plots using that information, they can do that with the dataframes produced from missing , which is exactly what plot_missing does under the hood! Accessibility Documentation is everything! We recognize Julia is a comparatively young language, and we know which languages and packages other population geneticists are using for their work. We want you to be comfortable using PopGen.jl , and that means investing a lot of time into writing thorough documentation intended for users (vs developers). We also recognize that you (the reader) might not be very familiar with Julia, or any language other than R (which is ok!), so we've written a section on clarifying some Julia concepts/conventions that will make reading this documentation a whole lot clearer. It is by no means a replacement for sitting down and learning the Julia language a bit ( here is a great online book on that ), but it should hopefully reduce the barrier of entry somewhat.","title":"Goal"},{"location":"#why-julia-and-not-python-or-r","text":"Speed and syntax The speed is comparable to C when coded correctly. Also, has Python-like syntax with optional tabs. We are also fans of 1-indexing, but that's more of a perk. A modern language for modern problems Julia has native support for: parallelization, distributed computing, GPU processing, and pipes! It also has robust machine learning packages (maybe for future implementations). Community & contribution Julia's just-in-time type-safe and optimized compiling solves what's known as the \"two language problem\". That is, languages that are easy to write in are slow, and languages that are more difficult to write in are fast. Interpreted languages, like Python, R, and Perl are easier to write in, however many of the commonly used packages and functions in those languages are written in another, faster language under the hood for performance reasons. On the whole, that's not really a problem for end-users, because functions work and they are easy to use. But , it does become a problem when you want to investigate the code and implementation of a function. This means that, even as an R power-user, you are powerless to investigate the implementation of something you are using if it's actually written in C++. In a sense, it makes the publications of those methods less reproducible, because the users of it may be familiar with the language it's deployed in (like R), but not the language it's written in, (like C++). What if there are bugs?! What if the code implementation doesn't match the formulations in the publication?! Yikes! And thus solving the two language problem, users can themselves diagnose code if they so choose. Yes, that means that we might be getting more Issues opened up, but a bug found is a lot better than a bug overlooked! Like most Julia packages, PopGen.jl is written entirely in Julia, meaning the community using it need not learn another language if they wanted to contribute! Have you written a clever Julia function to calculate SAMOVA from a PopObj ? Send us a pull request! (please!) Package manager Which is such a delight to use.","title":"Why Julia and not Python or R?"},{"location":"#authors","text":"Pavel Dimens, PhD Student @ U. Southern Mississippi Jason Selwyn, PhD Candidate @ Texas A&M University - Corpus Christi","title":"Authors"},{"location":"contr/","text":"Contributing We absolutely welcome contributors to this package/project! Contributing can take the form of: Optimizing available code Pointing out bugs (and troubleshooting them if possible!) Testing your data against the available code Writing new functions or methods for existing functions Spreading the word on social media Words of encouragement","title":"Contributing"},{"location":"contr/#contributing","text":"We absolutely welcome contributors to this package/project! Contributing can take the form of: Optimizing available code Pointing out bugs (and troubleshooting them if possible!) Testing your data against the available code Writing new functions or methods for existing functions Spreading the word on social media Words of encouragement","title":"Contributing"},{"location":"delimited/","text":"Formatting Loci names must be first row Individuals names must be first value in row Population ID's must be second value in row Optional: longitude (x) values third value in row, latitude (y) fourth Formatting examples without locations Locus1,Locus2,Locus3 sierra_01,1,001001,002002,001001 sierra_02,1,001001,001001,001002 snbarb_03,2,001001,001001,001002 snbarb_02,2,001001,001001,001001 snbarb_03,2,001002,001001,001001 with locations Locus1,Locus2,Locus3 sierra_01,1,14.1,15.2,001001,002002,001001 sierra_02,1,34.1,26.1,001001,001001,001002 snbarb_03,2,45.1,-11.2,001001,001001,001002 snbarb_02,2,-11.5,11.6,001001,001001,001001 snbarb_03,2,-3.1,43.2,001002,001001,001001 Importing a CSV into Julia as a PopObj csv ( infile ; delim , ploidy = 2 , location = false ) # Example a = csv ( \"/data/cali_poppy.csv\" , delim = \",\" , ploidy = 2 ) Arguments infile :: String : path to the input file, in quotes Keyword Arguments delim :: Union { Char , String , Regex } : delimiter of the file, can be a string, character, or regex comma: delim = \",\" space: delim = \" \" tab: delim = \"\\t\" etc. ploidy :: Int64 : single integer of the ploidy of the samples in the file (default = 2) haploid: ploidy = 1 diploid: ploidy = 2 triploid: ploidy = 3 etc. location :: Bool = false : true/false of whether location data is present in the file (default = false)","title":"CSV and delimited"},{"location":"delimited/#formatting","text":"Loci names must be first row Individuals names must be first value in row Population ID's must be second value in row Optional: longitude (x) values third value in row, latitude (y) fourth","title":"Formatting"},{"location":"delimited/#formatting-examples","text":"without locations Locus1,Locus2,Locus3 sierra_01,1,001001,002002,001001 sierra_02,1,001001,001001,001002 snbarb_03,2,001001,001001,001002 snbarb_02,2,001001,001001,001001 snbarb_03,2,001002,001001,001001 with locations Locus1,Locus2,Locus3 sierra_01,1,14.1,15.2,001001,002002,001001 sierra_02,1,34.1,26.1,001001,001001,001002 snbarb_03,2,45.1,-11.2,001001,001001,001002 snbarb_02,2,-11.5,11.6,001001,001001,001001 snbarb_03,2,-3.1,43.2,001002,001001,001001","title":"Formatting examples"},{"location":"delimited/#importing-a-csv-into-julia-as-a-popobj","text":"csv ( infile ; delim , ploidy = 2 , location = false ) # Example a = csv ( \"/data/cali_poppy.csv\" , delim = \",\" , ploidy = 2 )","title":"Importing a CSV into Julia as a PopObj"},{"location":"delimited/#arguments","text":"infile :: String : path to the input file, in quotes","title":"Arguments"},{"location":"delimited/#keyword-arguments","text":"delim :: Union { Char , String , Regex } : delimiter of the file, can be a string, character, or regex comma: delim = \",\" space: delim = \" \" tab: delim = \"\\t\" etc. ploidy :: Int64 : single integer of the ploidy of the samples in the file (default = 2) haploid: ploidy = 1 diploid: ploidy = 2 triploid: ploidy = 3 etc. location :: Bool = false : true/false of whether location data is present in the file (default = false)","title":"Keyword Arguments"},{"location":"editing/","text":"Editing PopObj elements Following standard Julia convention, functions ending with ! are mutable, meaning they will edit the input. To follow along, load in the provided test data in /test/testdata.gen using PopGen a = genepop ( \"/test/testdata.gen\" , numpops = 7 ) Keep in mind, your path to that file is probably different. If using windows make sure to change your backslashes \"\\\" to forward slashes \"/\" add location data Location data can be added by directly accessing the fields .longitude and .latitude in your PopObj a . longitude = rand ( 1 : 50 , 212 ) # creates 212 unique random numbers between 1 and 50 a . latitdue = rand ( 20 : 30 , 212 ) # creates 212 unique random numbers between 20 and 30 However, if your data is in decimal minutes rather than decimal degrees, use the locations! function to add it to the fields. This function will do a conversion for you. adding decimal minutes data locations! ( x :: PopObj ; xloc :: Array , yloc :: Array ) Adds location data (longitude, latitude) to PopObj . Takes decimal degrees or decimal minutes format. Must use minus-sign instead of cardinal directions (i.e. 14 32.11W is not vaild). Location data must be in order of individuals ( ind ). Replaces existing PopObj location data. Decimal Degrees : -11.431 Decimal Minutes : \"-11 43.11\" (must use space and double-quotes) If conversion is not necessary, can directly assign PopObj.longitude and PopObj.latitude as shown above. rename populations popid! ( x :: PopObj ; rename :: Dict ) Rename the population ID's of PopObj.popid . Uses a Dict of [popid] => replacement to rename Example: # create a dictionary of name conversions new_popnames = Dict ( 1 => \"Cape Canaveral\" , 2 => \"Georgia\" , 3 => \"S Carolina\" , 4 => \"FL Keys\" , 5 => \"Mideast Gulf\" , 6 => \"Northeast Gulf\" , 7 => \"Southeast Gulf\" ) popid! ( x , rename = new_popnames ) remove loci remove_loci! ( x :: PopObj , loci :: Union { String , Array { String , 1 }}) Removes selected loci from a PopObj . Examples: remove_loci! ( a , \"contig_35208\" ) remove_loci! ( a , [ \"contig_35208\" , \"contig_23109\" , \"contig_4493\" ]) remove individuals remove_inds! ( x :: PopObj , inds :: Union { Array { String , 1 }}) Removes selected individuals from a PopObj . Examples: remove_inds! ( a , \"cca_001\" ) remove_inds ( a , [ \"cca_001\" , \"cca_002\" , \"cca_003\" ])","title":"Editing PopObj"},{"location":"editing/#editing-popobj-elements","text":"Following standard Julia convention, functions ending with ! are mutable, meaning they will edit the input. To follow along, load in the provided test data in /test/testdata.gen using PopGen a = genepop ( \"/test/testdata.gen\" , numpops = 7 ) Keep in mind, your path to that file is probably different. If using windows make sure to change your backslashes \"\\\" to forward slashes \"/\"","title":"Editing PopObj elements"},{"location":"editing/#add-location-data","text":"Location data can be added by directly accessing the fields .longitude and .latitude in your PopObj a . longitude = rand ( 1 : 50 , 212 ) # creates 212 unique random numbers between 1 and 50 a . latitdue = rand ( 20 : 30 , 212 ) # creates 212 unique random numbers between 20 and 30 However, if your data is in decimal minutes rather than decimal degrees, use the locations! function to add it to the fields. This function will do a conversion for you.","title":"add location data"},{"location":"editing/#adding-decimal-minutes-data","text":"locations! ( x :: PopObj ; xloc :: Array , yloc :: Array ) Adds location data (longitude, latitude) to PopObj . Takes decimal degrees or decimal minutes format. Must use minus-sign instead of cardinal directions (i.e. 14 32.11W is not vaild). Location data must be in order of individuals ( ind ). Replaces existing PopObj location data. Decimal Degrees : -11.431 Decimal Minutes : \"-11 43.11\" (must use space and double-quotes) If conversion is not necessary, can directly assign PopObj.longitude and PopObj.latitude as shown above.","title":"adding decimal minutes data"},{"location":"editing/#rename-populations","text":"popid! ( x :: PopObj ; rename :: Dict ) Rename the population ID's of PopObj.popid . Uses a Dict of [popid] => replacement to rename Example: # create a dictionary of name conversions new_popnames = Dict ( 1 => \"Cape Canaveral\" , 2 => \"Georgia\" , 3 => \"S Carolina\" , 4 => \"FL Keys\" , 5 => \"Mideast Gulf\" , 6 => \"Northeast Gulf\" , 7 => \"Southeast Gulf\" ) popid! ( x , rename = new_popnames )","title":"rename populations"},{"location":"editing/#remove-loci","text":"remove_loci! ( x :: PopObj , loci :: Union { String , Array { String , 1 }}) Removes selected loci from a PopObj . Examples: remove_loci! ( a , \"contig_35208\" ) remove_loci! ( a , [ \"contig_35208\" , \"contig_23109\" , \"contig_4493\" ])","title":"remove loci"},{"location":"editing/#remove-individuals","text":"remove_inds! ( x :: PopObj , inds :: Union { Array { String , 1 }}) Removes selected individuals from a PopObj . Examples: remove_inds! ( a , \"cca_001\" ) remove_inds ( a , [ \"cca_001\" , \"cca_002\" , \"cca_003\" ])","title":"remove individuals"},{"location":"genepop/","text":"Format Files must follow standard Genepop formatting: First line is a comment (and skipped) Loci are listed after first line as one-per-line without commas or in single comma-separated row A line with a particular keyword must delimit populations Must be the same word each time and not a unique population name File is tab or space delimted Formatting Examples loci stacked vertically Wasp populations in New York Locus1 Locus2 Locus3 POP Oneida_01, 250230 564568 110100 Oneida_02, 252238 568558 100120 Oneida_03, 254230 564558 090100 POP Newcomb_01, 254230 564558 080100 Newcomb_02, 000230 564558 090080 Newcomb_03, 254230 000000 090100 Newcomb_04, 254230 564000 090120 loci stacked horizontally Wasp populations in New York Locus1,Locus2,Locus3 POP Oneida_01, 250230 564568 110100 Oneida_02, 252238 568558 100120 Oneida_03, 254230 564558 090100 POP Newcomb_01, 254230 564558 080100 Newcomb_02, 000230 564558 090080 Newcomb_03, 254230 000000 090100 Newcomb_04, 254230 564000 090120 Import a genepop file into Julia as a PopObj genepop ( infile ; ploidy = 2 , popsep = \"POP\" , numpop ) # Example b = genepop ( \"/data/wasp_hive.gen\" , ploidy = 2 , popsep = \"POP\" , numpops = 2 ) Arguments infile::String : path to genepop file, in quotes Keyword Arguments ploidy::Int64 : single integer of the ploidy of the samples in the file (default = 2) haploid: ploidy = 1 diploid: ploidy = 2 triploid: ploidy = 3 etc. popsep::String : word that separates populations in infile (default: \"POP\") numpops::Int64 : number of populations present in infile (used for early error checking) Note By default, the file reader will assign numbers as population ID's in order of appearance in the genepop file. Use the popid! function to rename these with your own population ID's.","title":"Genepop"},{"location":"genepop/#format","text":"Files must follow standard Genepop formatting: First line is a comment (and skipped) Loci are listed after first line as one-per-line without commas or in single comma-separated row A line with a particular keyword must delimit populations Must be the same word each time and not a unique population name File is tab or space delimted","title":"Format"},{"location":"genepop/#formatting-examples","text":"loci stacked vertically Wasp populations in New York Locus1 Locus2 Locus3 POP Oneida_01, 250230 564568 110100 Oneida_02, 252238 568558 100120 Oneida_03, 254230 564558 090100 POP Newcomb_01, 254230 564558 080100 Newcomb_02, 000230 564558 090080 Newcomb_03, 254230 000000 090100 Newcomb_04, 254230 564000 090120 loci stacked horizontally Wasp populations in New York Locus1,Locus2,Locus3 POP Oneida_01, 250230 564568 110100 Oneida_02, 252238 568558 100120 Oneida_03, 254230 564558 090100 POP Newcomb_01, 254230 564558 080100 Newcomb_02, 000230 564558 090080 Newcomb_03, 254230 000000 090100 Newcomb_04, 254230 564000 090120","title":"Formatting Examples"},{"location":"genepop/#import-a-genepop-file-into-julia-as-a-popobj","text":"genepop ( infile ; ploidy = 2 , popsep = \"POP\" , numpop ) # Example b = genepop ( \"/data/wasp_hive.gen\" , ploidy = 2 , popsep = \"POP\" , numpops = 2 )","title":"Import a genepop file into Julia as a PopObj"},{"location":"genepop/#arguments","text":"infile::String : path to genepop file, in quotes","title":"Arguments"},{"location":"genepop/#keyword-arguments","text":"ploidy::Int64 : single integer of the ploidy of the samples in the file (default = 2) haploid: ploidy = 1 diploid: ploidy = 2 triploid: ploidy = 3 etc. popsep::String : word that separates populations in infile (default: \"POP\") numpops::Int64 : number of populations present in infile (used for early error checking) Note By default, the file reader will assign numbers as population ID's in order of appearance in the genepop file. Use the popid! function to rename these with your own population ID's.","title":"Keyword Arguments"},{"location":"install/","text":"Installation Installing PopGen.jl The package is currently unregistered while it's under active early development. However, installation is still simple! Invoke the package manager with ] in the REPL and use add \"https://github.com/pdimens/PopGen.jl\" If using Jupyter Notebooks or nteract, install the package in julia with using Pkg Pkg . add ( \"https://github.com/pdimens/PopGen.jl\" ) Feel free to play around with the test data in /test/testdata.gen Using PopGen Like all Julia packages, to activate PopGen , simply run: using PopGen Performance notes If you're migrating to Julia from Python or R (or Matlab, etc.), you'll think Julia is slow and laggy because loading packages and running stuff has a noticeable wait time (10-40sec). However, if this is your first time in Julia, then it's worth mentioning that this lag is \"compilation overhead\". What this means is, Julia tries to pre-compile as much code as possible (into optimized machine code) when running something or loading a package. This lag exists only the first time you run something. Every subsequent run of a function, even with different parameters, will be substantially faster, and in most cases instant. If you want to test this yourself, try to run a line of code twice with @time before the function and compare the results. Here's an example: julia > @time using PopGen 17.415902 seconds (19.88 M allocations: 1.022 GiB, 2.79% gc time) julia > @time using PopGen 0.100233 seconds (64.07 k allocations: 3.123 MiB, 6.02% gc time)","title":"Installing"},{"location":"install/#installation","text":"","title":"Installation"},{"location":"install/#installing-popgenjl","text":"The package is currently unregistered while it's under active early development. However, installation is still simple! Invoke the package manager with ] in the REPL and use add \"https://github.com/pdimens/PopGen.jl\" If using Jupyter Notebooks or nteract, install the package in julia with using Pkg Pkg . add ( \"https://github.com/pdimens/PopGen.jl\" ) Feel free to play around with the test data in /test/testdata.gen","title":"Installing PopGen.jl"},{"location":"install/#using-popgen","text":"Like all Julia packages, to activate PopGen , simply run: using PopGen Performance notes If you're migrating to Julia from Python or R (or Matlab, etc.), you'll think Julia is slow and laggy because loading packages and running stuff has a noticeable wait time (10-40sec). However, if this is your first time in Julia, then it's worth mentioning that this lag is \"compilation overhead\". What this means is, Julia tries to pre-compile as much code as possible (into optimized machine code) when running something or loading a package. This lag exists only the first time you run something. Every subsequent run of a function, even with different parameters, will be substantially faster, and in most cases instant. If you want to test this yourself, try to run a line of code twice with @time before the function and compare the results. Here's an example: julia > @time using PopGen 17.415902 seconds (19.88 M allocations: 1.022 GiB, 2.79% gc time) julia > @time using PopGen 0.100233 seconds (64.07 k allocations: 3.123 MiB, 6.02% gc time)","title":"Using PopGen"},{"location":"juliaprimer/","text":"A quick Julia primer for getting the most out of this documentation There is nothing inherently special about this documentation relative to other documentation, other than we really really want you to get the most out of what's written here. This means that we need to embrace the fact that both novice and experienced Julia users may be reading these docs and using this package. So let's cover some Julia basics that will really help in navigating this package before we even get into the complicated genetics stuff. This primer is by no means \"everything you need to get started in Julia\", and is a poor substitute for actually learning the language. In general, we recommend Think Julia: How to Think Like a Data Scientist by Ben Lauwens to establish some solid Julia foundations. It's free online! Semicolons Semicolons will come up a lot in Julia, probably more than you would expect if you are migrating from another language. They mean different thing depending on where they are. At the end of a command When you see a semicolon after invoking a function, what that means is \"don't show me the output in the terminal window\". Example: julia > x = 2 + 2 4 julia > x = 10 + 2 ; julia > x 12 Julia will still process the command and assign 10 + 2 to x , but it won't show you the output in the terminal. We sometimes include a semicolon after commands in these docs to mimic what the REPL output would look like without spitting back out an array of over 200 values. These semicolons are optional In between assignment commands If you see a semicolon in between two variable assignments, like so: x = [ 1 , 2 ] ; y = [ 3 , 4 ] that's a Julia short-hand for making two short lines of code appear on a single line. It's the equivalent of doing: x = [ 1 , 2 ] y = [ 3 , 4 ] We sometimes choose this writing format for very quick and small assignments hoping to save some visual space. Use whichever method is most comfortable and sensible for you! Help mode To enter help mode in the REPL, simply press the question mark key ? (shift + key) and you will notice a different prompt help?> for you to type in a function. help ?> popid search: popid popid! popfirst! popdisplay precompile __precompile__ CompositeException popid(x::PopObj; listall::Bool = false) View unique population ID's in a PopObj. listall = true, displays ind and their popid instead (default = false). Type information Julia encourages strong typing of variables, and the functions in PopGen are no exception to this. However, to reduce the barrier of entry required to understand this documentation and the subsequent package, we have chosen to omit some of the type information from functions to reduce visual clutter for newer users. As experienced users already know, if you would like to see the explicit type information, you can look at the code on github, invoke the help system in the REPL (above), or search for a function in the Documentation pane in Juno. You'll notice types follow a specific format, which is object::type . This format is a type assignment, so in the function popid , which looks like: popid(x::PopObj; listall::Bool = false) : x is a variable of type PopObj listall is a variable of type Bool (boolean) meaning it only takes true or false without quotes Type Unions You might see the type Union appear occasionally throughout this documentation, and you can consider it a list of types. For example, if something was of type ::Union{String,Integer} , that means that either a String or Integer works. These kinds of Union appear in a few places, like remove_inds! , where the input can be either a String (a single individual) or an Array{String,1} (one-dimensional list of names). For remove_inds! , the second argument type appears as ::Union{String, Array{String,1}} . Also, the order in which types appear in Union types don't matter. Functions vs. Methods As part of Julia's type-safe paradigm and multiple dispatch (see \"ERROR: MethodError: no method matching\" below), type specifications in functions often reduce runtime of functions, but also establish function identity. Multiple dispatch refers to several different functions having the same name, but employing different methods depending on the input. In Julia, it's easier to write a single function with multiple type-safe methods, rather than one mega-function that accepts any type and have a bunch of if statements that determines what the program does depending on the input. In practice, this looks like: # combine two numbers julia> function add(x::Integer, y::Integer) x+y end add (generic function with 1 method) # combine two strings julia> function add(x::String, y::String) x*y end add (generic function with 2 methods) julia> add(1,2) 3 julia> add(\"water\", \"melon\") \"watermelon\" Multiple dispatch therefor leads to a unique type of possible error: the MethodError ERROR: MethodError: no method matching Using the function add from the example above, let's have a look at what happens when we try to add an Integer with a String : julia > add ( 1 , \"melon\" ) ERROR : MethodError : no method matching add ( :: Int64 , :: String ) Closest candidates are : add ( :: String , :: String ) at none : 2 add ( :: Integer , :: Integer ) at none : 2 Stacktrace : [ 1 ] top - level scope at none : 0 This error is telling us \"there is no such function called add , who's inputs are an Integer followed by a String \". But, it does offer us some alternatives, like the two add functions we created earlier. The functions within PopGen are almost always explicitly typed, so if you are getting the MethodError: no method matching error, then you are inputting the incorrect types into the function, or perhaps your inputs for the arguments are in the wrong order (see \"Functions with and without keywords\" below). keep in mind MethodError's can definitely get annoying, but they are usually the result of incorrect input from the user and not buggy programming by the developers. Please take that into consideration before assuming something is broken or bugged. Functions with and without keywords TL;DR Reading these docs, pay attention to semicolons in the function argument lists. arguments before a semicolon have no keyword and follow an explicit order arguments after a semicolon have a keyword argument = value and their order doesn't matter MethodError: no methods matching is more likely an issue on your side and not on our side unless we accidentally forgot to export a function! Broadly speaking, there are two types of function declarations in Julia: ones with keywords and ones without keywords. The term \"keywords\" refers to an input argument that has the format argument = value . This format is present in many of the functions in this and other packages, however there are some specifics to understand when functions use keywords and when they don't. Format 1: Strict argument order and no keywords - No semicolon in argument list function function_name ( var1 :: type , var2 :: type , var3 :: type ) do stuff with vars end If a function is declared with only commas in the argument list, like shown above, then the arguments to that function must have no keywords and follow the exact order they appear in. If the generic example above had the typing: function function_name ( var1 :: String , var2 :: Float64 , var3 :: Array { String , 1 }) do stuff with vars end then the only acceptable way to run this function without getting a MethodError would be with arguments in the order of function_name(String, Float64, Array{String,1}) . Even if some of the arguments have a default values, like var2::Float64 = 6.66 , the order of arguments/types has to be respected as declared. Format 2 - semicolon in argument list function function_name ( var1 :: type ; var2 :: type , var3 :: type ) do stuff with vars end In this format, everything that comes before the semicolon follows the strict rules from Format 1 , and everything that comes after the semicolon is a keyword argument. Keyword arguments have the flexibility to not require any particular input order. However, you must use the keywords to declare those arguments, or you will receive another MethodError: no method matching , which is, as we've mentioned, annoying.","title":"A Julia Primer"},{"location":"juliaprimer/#a-quick-julia-primer-for-getting-the-most-out-of-this-documentation","text":"There is nothing inherently special about this documentation relative to other documentation, other than we really really want you to get the most out of what's written here. This means that we need to embrace the fact that both novice and experienced Julia users may be reading these docs and using this package. So let's cover some Julia basics that will really help in navigating this package before we even get into the complicated genetics stuff. This primer is by no means \"everything you need to get started in Julia\", and is a poor substitute for actually learning the language. In general, we recommend Think Julia: How to Think Like a Data Scientist by Ben Lauwens to establish some solid Julia foundations. It's free online!","title":"A quick Julia primer for getting the most out of this documentation"},{"location":"juliaprimer/#semicolons","text":"Semicolons will come up a lot in Julia, probably more than you would expect if you are migrating from another language. They mean different thing depending on where they are.","title":"Semicolons"},{"location":"juliaprimer/#at-the-end-of-a-command","text":"When you see a semicolon after invoking a function, what that means is \"don't show me the output in the terminal window\". Example: julia > x = 2 + 2 4 julia > x = 10 + 2 ; julia > x 12 Julia will still process the command and assign 10 + 2 to x , but it won't show you the output in the terminal. We sometimes include a semicolon after commands in these docs to mimic what the REPL output would look like without spitting back out an array of over 200 values. These semicolons are optional","title":"At the end of a command"},{"location":"juliaprimer/#in-between-assignment-commands","text":"If you see a semicolon in between two variable assignments, like so: x = [ 1 , 2 ] ; y = [ 3 , 4 ] that's a Julia short-hand for making two short lines of code appear on a single line. It's the equivalent of doing: x = [ 1 , 2 ] y = [ 3 , 4 ] We sometimes choose this writing format for very quick and small assignments hoping to save some visual space. Use whichever method is most comfortable and sensible for you!","title":"In between assignment commands"},{"location":"juliaprimer/#help-mode","text":"To enter help mode in the REPL, simply press the question mark key ? (shift + key) and you will notice a different prompt help?> for you to type in a function. help ?> popid search: popid popid! popfirst! popdisplay precompile __precompile__ CompositeException popid(x::PopObj; listall::Bool = false) View unique population ID's in a PopObj. listall = true, displays ind and their popid instead (default = false).","title":"Help mode"},{"location":"juliaprimer/#type-information","text":"Julia encourages strong typing of variables, and the functions in PopGen are no exception to this. However, to reduce the barrier of entry required to understand this documentation and the subsequent package, we have chosen to omit some of the type information from functions to reduce visual clutter for newer users. As experienced users already know, if you would like to see the explicit type information, you can look at the code on github, invoke the help system in the REPL (above), or search for a function in the Documentation pane in Juno. You'll notice types follow a specific format, which is object::type . This format is a type assignment, so in the function popid , which looks like: popid(x::PopObj; listall::Bool = false) : x is a variable of type PopObj listall is a variable of type Bool (boolean) meaning it only takes true or false without quotes","title":"Type information"},{"location":"juliaprimer/#type-unions","text":"You might see the type Union appear occasionally throughout this documentation, and you can consider it a list of types. For example, if something was of type ::Union{String,Integer} , that means that either a String or Integer works. These kinds of Union appear in a few places, like remove_inds! , where the input can be either a String (a single individual) or an Array{String,1} (one-dimensional list of names). For remove_inds! , the second argument type appears as ::Union{String, Array{String,1}} . Also, the order in which types appear in Union types don't matter.","title":"Type Unions"},{"location":"juliaprimer/#functions-vs-methods","text":"As part of Julia's type-safe paradigm and multiple dispatch (see \"ERROR: MethodError: no method matching\" below), type specifications in functions often reduce runtime of functions, but also establish function identity. Multiple dispatch refers to several different functions having the same name, but employing different methods depending on the input. In Julia, it's easier to write a single function with multiple type-safe methods, rather than one mega-function that accepts any type and have a bunch of if statements that determines what the program does depending on the input. In practice, this looks like: # combine two numbers julia> function add(x::Integer, y::Integer) x+y end add (generic function with 1 method) # combine two strings julia> function add(x::String, y::String) x*y end add (generic function with 2 methods) julia> add(1,2) 3 julia> add(\"water\", \"melon\") \"watermelon\" Multiple dispatch therefor leads to a unique type of possible error: the MethodError","title":"Functions vs. Methods"},{"location":"juliaprimer/#error-methoderror-no-method-matching","text":"Using the function add from the example above, let's have a look at what happens when we try to add an Integer with a String : julia > add ( 1 , \"melon\" ) ERROR : MethodError : no method matching add ( :: Int64 , :: String ) Closest candidates are : add ( :: String , :: String ) at none : 2 add ( :: Integer , :: Integer ) at none : 2 Stacktrace : [ 1 ] top - level scope at none : 0 This error is telling us \"there is no such function called add , who's inputs are an Integer followed by a String \". But, it does offer us some alternatives, like the two add functions we created earlier. The functions within PopGen are almost always explicitly typed, so if you are getting the MethodError: no method matching error, then you are inputting the incorrect types into the function, or perhaps your inputs for the arguments are in the wrong order (see \"Functions with and without keywords\" below). keep in mind MethodError's can definitely get annoying, but they are usually the result of incorrect input from the user and not buggy programming by the developers. Please take that into consideration before assuming something is broken or bugged.","title":"ERROR: MethodError: no method matching"},{"location":"juliaprimer/#functions-with-and-without-keywords","text":"TL;DR Reading these docs, pay attention to semicolons in the function argument lists. arguments before a semicolon have no keyword and follow an explicit order arguments after a semicolon have a keyword argument = value and their order doesn't matter MethodError: no methods matching is more likely an issue on your side and not on our side unless we accidentally forgot to export a function! Broadly speaking, there are two types of function declarations in Julia: ones with keywords and ones without keywords. The term \"keywords\" refers to an input argument that has the format argument = value . This format is present in many of the functions in this and other packages, however there are some specifics to understand when functions use keywords and when they don't.","title":"Functions with and without keywords"},{"location":"juliaprimer/#format-1-strict-argument-order-and-no-keywords-no-semicolon-in-argument-list","text":"function function_name ( var1 :: type , var2 :: type , var3 :: type ) do stuff with vars end If a function is declared with only commas in the argument list, like shown above, then the arguments to that function must have no keywords and follow the exact order they appear in. If the generic example above had the typing: function function_name ( var1 :: String , var2 :: Float64 , var3 :: Array { String , 1 }) do stuff with vars end then the only acceptable way to run this function without getting a MethodError would be with arguments in the order of function_name(String, Float64, Array{String,1}) . Even if some of the arguments have a default values, like var2::Float64 = 6.66 , the order of arguments/types has to be respected as declared.","title":"Format 1: Strict argument order and no keywords - No semicolon in argument list"},{"location":"juliaprimer/#format-2-semicolon-in-argument-list","text":"function function_name ( var1 :: type ; var2 :: type , var3 :: type ) do stuff with vars end In this format, everything that comes before the semicolon follows the strict rules from Format 1 , and everything that comes after the semicolon is a keyword argument. Keyword arguments have the flexibility to not require any particular input order. However, you must use the keywords to declare those arguments, or you will receive another MethodError: no method matching , which is, as we've mentioned, annoying.","title":"Format 2 - semicolon in argument list"},{"location":"plotting/","text":"Plotting The output of many functions are formatted for use in your favorite Julia plotting environments, such as Plots , Makie , PlotlyJS , PyPlot , Gadfly , etc. However, some convenience plots are provided to assist with speedy data visualization and exploration. plot missing data plot_missing ( x :: PopObj ; color = false ) Return an interactive plot of the number of missing loci in individuals of a PopObj , along with the number of missing individuals per locus. To set a custom color palette for the boxplots, use color = [color1, color2, ...] Example: julia > plot_missing ( a ) If you would like to save the interactive plot as a local HTML file (does not require Plotly account): using PlotlyJS PlotlyJS . savehtml ( plot_missing ( a ), \"filename.html\" ) This will save it in the current working directly as whatever you replace filename.html with. If you want the file to work properly offline, add a third argument :embed , although be aware it inflates the file size (~3.5mb for the test data). plot sample locations plot_locations(x::PopObj; region = \"world\", projection = \"orthographic\") Returns a simple lower resolution interactive scatterplot of the individuals in a PopObj . Default region and projection are \"world\" and \"orthographic\", respectively. If a specific region is set, the plot will default to \"mercator\" projection unless projection = is used to specify a different one. Example: julia > a . latitude = rand ( 10 : 30 , 212 ); a . longitude = rand ( - 99 :- 80 , 212 ) ; julia > plot_locations ( a ) julia > plot_locations ( a , region = \"north america\" , projection = \"mercator\" ) ` regions usa europe asia africa north america south america projections equirectangular mercator orthographic natural earth kavrayskiy7 miller robinson eckert4 azimuthal equal area azimuthal equidistant conic equal area conic conformal conic equidistant gnomonic stereographic mollweide hammer transverse mercator albers usa winkel tripel aitoff sinusoidal Saving As before, you can save the plot to an HTML file: using PlotlyJS PlotlyJS . savehtml ( plot_locations ( a , region = \"north america\" , projection = \"mercator\" ), \"filename.html\" )","title":"Plotting"},{"location":"plotting/#plotting","text":"The output of many functions are formatted for use in your favorite Julia plotting environments, such as Plots , Makie , PlotlyJS , PyPlot , Gadfly , etc. However, some convenience plots are provided to assist with speedy data visualization and exploration.","title":"Plotting"},{"location":"plotting/#plot-missing-data","text":"plot_missing ( x :: PopObj ; color = false ) Return an interactive plot of the number of missing loci in individuals of a PopObj , along with the number of missing individuals per locus. To set a custom color palette for the boxplots, use color = [color1, color2, ...] Example: julia > plot_missing ( a ) If you would like to save the interactive plot as a local HTML file (does not require Plotly account): using PlotlyJS PlotlyJS . savehtml ( plot_missing ( a ), \"filename.html\" ) This will save it in the current working directly as whatever you replace filename.html with. If you want the file to work properly offline, add a third argument :embed , although be aware it inflates the file size (~3.5mb for the test data).","title":"plot missing data"},{"location":"plotting/#plot-sample-locations","text":"plot_locations(x::PopObj; region = \"world\", projection = \"orthographic\") Returns a simple lower resolution interactive scatterplot of the individuals in a PopObj . Default region and projection are \"world\" and \"orthographic\", respectively. If a specific region is set, the plot will default to \"mercator\" projection unless projection = is used to specify a different one. Example: julia > a . latitude = rand ( 10 : 30 , 212 ); a . longitude = rand ( - 99 :- 80 , 212 ) ; julia > plot_locations ( a ) julia > plot_locations ( a , region = \"north america\" , projection = \"mercator\" ) ` regions usa europe asia africa north america south america projections equirectangular mercator orthographic natural earth kavrayskiy7 miller robinson eckert4 azimuthal equal area azimuthal equidistant conic equal area conic conformal conic equidistant gnomonic stereographic mollweide hammer transverse mercator albers usa winkel tripel aitoff sinusoidal Saving As before, you can save the plot to an HTML file: using PlotlyJS PlotlyJS . savehtml ( plot_locations ( a , region = \"north america\" , projection = \"mercator\" ), \"filename.html\" )","title":"plot sample locations"},{"location":"popobj_accessing/","text":"Accessing any of these fields is done with a dot . accessor and can use the [] slice accessor, as per standard Julia convention: julia> a = genepop(\"/test/testdata.gen\", numpops = 7) ; julia> a.ind[1:6] 6-element Array{String,1}: \"cca_001\" \"cca_002\" \"cca_003\" \"cca_005\" \"cca_007\" \"cca_008\" julia> a.loci[1:6] 6-element Array{String,1}: \"Contig_35208\" \"Contig_23109\" \"Contig_4493\" \"Contig_10742\" \"Contig_14898\" \"Contig_8483\" julia> a.ploidy 2 julia> unique(a.popid) 7-element Array{String,1}: \"1\" \"2\" \"3\" \"4\" \"5\" \"6\" \"7\"","title":"Accessing"},{"location":"popobj_location/","text":"Location Data Notice the No location data provided text on the second line of output when you show a PopObj , like demonstrated on the previous page. That text exists as a \"heads up\" rather than a warning because location data is optional for a PopObj . There are functions that use location information (e.g. locations and plot_locations ), but most don't, so it's not a dealbreaker. If you add location information, displaying the PopObj again will show you output now including this information: # assign random location data julia> a.latitude = rand(1:50, 212) ; julia> a.longitude = rand(1:50, 212) ; julia> a Object of type PopObj: Longitude: [\"26\", \"7\", \"21\"] \u2026 [\"25\", \"26\", \"29\"] Latitude: [\"10\", \"10\", \"40\"] \u2026 [\"3\", \"5\", \"46\"] Number of individuals: 212 [\"cca_001\", \"cca_002\", \"cca_003\"] \u2026 [\"seg_029\", \"seg_030\", \"seg_031\"] Number of loci: 2213 [\"Contig_35208\", \"Contig_23109\", \"Contig_4493\"] \u2026 [\"Contig_19384\", \"Contig_22368\", \"Contig_2784\"] Ploidy: 2 Number of populations: 7 #Inds | Pop -------------- 21 | 1 30 | 2 28 | 3 65 | 4 28 | 5 20 | 6 20 | 7 Available fields: ind, popid, loci, ploidy, genotypes, longitude, latitude Info While showing a PopObj represents location data as strings, they are actually coded as integers or floating point numbers. This was a design decision to remove visual clutter, however we can easily revert it back to displaying Int or Float64 with type information if that's what users prefer.","title":"Location data"},{"location":"popobj_location/#location-data","text":"Notice the No location data provided text on the second line of output when you show a PopObj , like demonstrated on the previous page. That text exists as a \"heads up\" rather than a warning because location data is optional for a PopObj . There are functions that use location information (e.g. locations and plot_locations ), but most don't, so it's not a dealbreaker. If you add location information, displaying the PopObj again will show you output now including this information: # assign random location data julia> a.latitude = rand(1:50, 212) ; julia> a.longitude = rand(1:50, 212) ; julia> a Object of type PopObj: Longitude: [\"26\", \"7\", \"21\"] \u2026 [\"25\", \"26\", \"29\"] Latitude: [\"10\", \"10\", \"40\"] \u2026 [\"3\", \"5\", \"46\"] Number of individuals: 212 [\"cca_001\", \"cca_002\", \"cca_003\"] \u2026 [\"seg_029\", \"seg_030\", \"seg_031\"] Number of loci: 2213 [\"Contig_35208\", \"Contig_23109\", \"Contig_4493\"] \u2026 [\"Contig_19384\", \"Contig_22368\", \"Contig_2784\"] Ploidy: 2 Number of populations: 7 #Inds | Pop -------------- 21 | 1 30 | 2 28 | 3 65 | 4 28 | 5 20 | 6 20 | 7 Available fields: ind, popid, loci, ploidy, genotypes, longitude, latitude Info While showing a PopObj represents location data as strings, they are actually coded as integers or floating point numbers. This was a design decision to remove visual clutter, however we can easily revert it back to displaying Int or Float64 with type information if that's what users prefer.","title":"Location Data"},{"location":"popobj_type/","text":"For the PopGen.jl package to be consistent, a standard flexible data structure needs to be defined. The solution is a custom type called a PopObj . The struct is defined as: mutable struct PopObj ind :: Array { String , 1 } popid :: Array { Union { Int64 , String }, 1 } loci :: Array { String , 1 } ploidy :: Int64 genotypes :: Dict longitude :: Array { Union { Int64 , Float64 }, 1 } latitude :: Array { Union { Int64 , Float64 }, 1 } end pronouncing \"PopObj\" If you haven't already guessed, PopObj is a combination of the words Population and Object. PopObj is pronounced \"pop ob\" with a silent j because it rolls of the tongue better, but writing it as PopOb looks weird. Yes, I have lost sleep over this detail. - Pavel ind type : 1-dimension array of strings ::Array{String,1} The individual/sample names [ \"ind_001\" , \"ind_002\" , \"ind_003\" ] popid type : 1-dimension array of strings ::Array{String,1} The individual/sample population ID's (in the same order) [ \"borneo\" , \"borneo\" , \"new jersey\" ] loci type : 1-dimension array of strings ::Array{String,1} The name of the loci, as an array of strings [ \"locus_001\" , \"locus_2\" , \"super-awesome-locus-3\" ] ploidy type: : Int64 The ploidy of the samples 2 genotypes type: : ::Dict of [loci] => Array{Tuple,1} The genotypes of the loci , as a dictionary of loci => genotypes. The loci are the dictionary keys keys , and the genotype values are an array of tuples , with each value corresponding to an allele. [\"locus_001\"] => [(0,1),(0,0),(1,2)] [\"locus_002\"] => [(0,0),(1,1),(2,2)] Important We use the immutable (cannot be changed) tuple type for genotypes of individuals because by the time you're using PopGen.jl , your data should already be filtered and screened. Hand-editing of genotype values is strongly discouraged, and we don't much like the idea of using this package to fudge your data that way. longitude type : one-dimensional array of integers or floating point numbers ::Array{Union{Int64,Float64},1} longitude data of samples (decimal degrees) [-11.12, 15.32, 11.02, -4] latitude type : one-dimensional array of integers or floating point numbers ::Array{Union{Int64,Float64},1} latitude data of samples (decimal degrees) [-11.12, 15.32, 11.02, -4] Viewing a PopObj Given the volume of information that can be present in a PopObj , we defined a custom Base.show(::PopObj) to summarize the data rather than regurgitate everything on the screen. julia> a Object of type PopObj: No location data provided Number of individuals: 212 [\"cca_001\", \"cca_002\", \"cca_003\"] \u2026 [\"seg_029\", \"seg_030\", \"seg_031\"] Number of loci: 2213 [\"Contig_35208\", \"Contig_23109\", \"Contig_4493\"] \u2026 [\"Contig_19384\", \"Contig_22368\", \"Contig_2784\"] Ploidy: 2 Number of populations: 7 #Inds | Pop -------------- 21 | 1 30 | 2 28 | 3 65 | 4 28 | 5 20 | 6 20 | 7 Available fields: ind, popid, loci, ploidy, genotypes, longitude, latitude For context, this is what /test/testdata.gen looks like without a custom show function \ud83e\udd2e :","title":"What's a PopObj"},{"location":"popobj_type/#ind","text":"type : 1-dimension array of strings ::Array{String,1} The individual/sample names [ \"ind_001\" , \"ind_002\" , \"ind_003\" ]","title":"ind"},{"location":"popobj_type/#popid","text":"type : 1-dimension array of strings ::Array{String,1} The individual/sample population ID's (in the same order) [ \"borneo\" , \"borneo\" , \"new jersey\" ]","title":"popid"},{"location":"popobj_type/#loci","text":"type : 1-dimension array of strings ::Array{String,1} The name of the loci, as an array of strings [ \"locus_001\" , \"locus_2\" , \"super-awesome-locus-3\" ]","title":"loci"},{"location":"popobj_type/#ploidy","text":"type: : Int64 The ploidy of the samples 2","title":"ploidy"},{"location":"popobj_type/#genotypes","text":"type: : ::Dict of [loci] => Array{Tuple,1} The genotypes of the loci , as a dictionary of loci => genotypes. The loci are the dictionary keys keys , and the genotype values are an array of tuples , with each value corresponding to an allele. [\"locus_001\"] => [(0,1),(0,0),(1,2)] [\"locus_002\"] => [(0,0),(1,1),(2,2)] Important We use the immutable (cannot be changed) tuple type for genotypes of individuals because by the time you're using PopGen.jl , your data should already be filtered and screened. Hand-editing of genotype values is strongly discouraged, and we don't much like the idea of using this package to fudge your data that way.","title":"genotypes"},{"location":"popobj_type/#longitude","text":"type : one-dimensional array of integers or floating point numbers ::Array{Union{Int64,Float64},1} longitude data of samples (decimal degrees) [-11.12, 15.32, 11.02, -4]","title":"longitude"},{"location":"popobj_type/#latitude","text":"type : one-dimensional array of integers or floating point numbers ::Array{Union{Int64,Float64},1} latitude data of samples (decimal degrees) [-11.12, 15.32, 11.02, -4]","title":"latitude"},{"location":"popobj_type/#viewing-a-popobj","text":"Given the volume of information that can be present in a PopObj , we defined a custom Base.show(::PopObj) to summarize the data rather than regurgitate everything on the screen. julia> a Object of type PopObj: No location data provided Number of individuals: 212 [\"cca_001\", \"cca_002\", \"cca_003\"] \u2026 [\"seg_029\", \"seg_030\", \"seg_031\"] Number of loci: 2213 [\"Contig_35208\", \"Contig_23109\", \"Contig_4493\"] \u2026 [\"Contig_19384\", \"Contig_22368\", \"Contig_2784\"] Ploidy: 2 Number of populations: 7 #Inds | Pop -------------- 21 | 1 30 | 2 28 | 3 65 | 4 28 | 5 20 | 6 20 | 7 Available fields: ind, popid, loci, ploidy, genotypes, longitude, latitude For context, this is what /test/testdata.gen looks like without a custom show function \ud83e\udd2e :","title":"Viewing a PopObj"},{"location":"vcf/","text":"Next on th To-Do list!","title":"VCF"},{"location":"viewing/","text":"Viewing elements in a PopObj A handful of convenience functions exist for viewing data. To follow along, load in the provided test data in /test/testdata.gen using PopGen a = genepop ( \"/test/testdata.gen\" , numpops = 7 ) keep in mind your path to that file is probably different, so make sure you set it correctly to where it is on your system. Windows users make sure to change your backslashes \"\\\" to forward slashes \"/\" individual/sample names indnames ( x :: PopObj ) View individual/sample names in a PopObj . This is equivalent to PopObj.ind Example: indnames ( a ) loci loci ( x :: PopObj , loci = nothing ) View the genotypes of all individuals for specific loci in a PopObj . Default shows all genotypes for all individuals. Add a second argument (no keywords!) to specify a single locus or array of loci to display. Examples: all loci loci ( a ) single locus loci ( a , \"contig_35208\" ) multiple loci loci ( a , [ \"contig_35208\" , \"contig_23109\" , \"contig_4493\" ]) locations locations ( x :: PopObj ) View location data ( .longitude and .latitude ) in a PopObj Example: locations ( a ) Info use locations! to add spatial data to a PopObj population ID's popid ( x :: PopObj ; listall :: Bool = false ) View unique population ID's in a PopObj . Default ( listall = false ) shows basic summary table of unique populations and the number of individuals in them. Use listall = true to display all individuals ( ind ) and their popid instead. Examples: summary of unique pops popid ( a ) every individual's population ID popid ( a , listall = true ) Info Use popid! to change the names of the populations genotypes genotypes ( x :: PopObj ; inds = nothing ) Show all the genotypes of specific individuals within a PopObj . Default is to show all individuals so use inds = to specify individuals. Names must be in quotes Examples: all individuals genotypes ( a ) single individual genotypes ( a , inds = \"cca_001\" ) multiple individuals genotypes ( a , inds = [ \"cca_001\" , \"cca_002\" , \"cca_003\" ]) missing loci missing ( x :: PopObj ) Identify and count missing loci in each individual of a PopObj . Returns a tuple of two DataFrames : loci per individual, number per loci. Example: missing ( a ) Info since missing outputs a tuple of 2 DataFrames, so you can assign two variables simultaneously to inherit the values of these dataframes, like so: miss_ind , miss_loci = missing ( a ) If you're coming from R, this concept of multiple assignment probably sounds crazy, but it's pretty common in Python and Julia! Embrace the convenience!","title":"Viewing Data"},{"location":"viewing/#viewing-elements-in-a-popobj","text":"A handful of convenience functions exist for viewing data. To follow along, load in the provided test data in /test/testdata.gen using PopGen a = genepop ( \"/test/testdata.gen\" , numpops = 7 ) keep in mind your path to that file is probably different, so make sure you set it correctly to where it is on your system. Windows users make sure to change your backslashes \"\\\" to forward slashes \"/\"","title":"Viewing elements in a PopObj"},{"location":"viewing/#individualsample-names","text":"indnames ( x :: PopObj ) View individual/sample names in a PopObj . This is equivalent to PopObj.ind Example: indnames ( a )","title":"individual/sample names"},{"location":"viewing/#loci","text":"loci ( x :: PopObj , loci = nothing ) View the genotypes of all individuals for specific loci in a PopObj . Default shows all genotypes for all individuals. Add a second argument (no keywords!) to specify a single locus or array of loci to display. Examples: all loci loci ( a ) single locus loci ( a , \"contig_35208\" ) multiple loci loci ( a , [ \"contig_35208\" , \"contig_23109\" , \"contig_4493\" ])","title":"loci"},{"location":"viewing/#locations","text":"locations ( x :: PopObj ) View location data ( .longitude and .latitude ) in a PopObj Example: locations ( a ) Info use locations! to add spatial data to a PopObj","title":"locations"},{"location":"viewing/#population-ids","text":"popid ( x :: PopObj ; listall :: Bool = false ) View unique population ID's in a PopObj . Default ( listall = false ) shows basic summary table of unique populations and the number of individuals in them. Use listall = true to display all individuals ( ind ) and their popid instead. Examples: summary of unique pops popid ( a ) every individual's population ID popid ( a , listall = true ) Info Use popid! to change the names of the populations","title":"population ID's"},{"location":"viewing/#genotypes","text":"genotypes ( x :: PopObj ; inds = nothing ) Show all the genotypes of specific individuals within a PopObj . Default is to show all individuals so use inds = to specify individuals. Names must be in quotes Examples: all individuals genotypes ( a ) single individual genotypes ( a , inds = \"cca_001\" ) multiple individuals genotypes ( a , inds = [ \"cca_001\" , \"cca_002\" , \"cca_003\" ])","title":"genotypes"},{"location":"viewing/#missing-loci","text":"missing ( x :: PopObj ) Identify and count missing loci in each individual of a PopObj . Returns a tuple of two DataFrames : loci per individual, number per loci. Example: missing ( a ) Info since missing outputs a tuple of 2 DataFrames, so you can assign two variables simultaneously to inherit the values of these dataframes, like so: miss_ind , miss_loci = missing ( a ) If you're coming from R, this concept of multiple assignment probably sounds crazy, but it's pretty common in Python and Julia! Embrace the convenience!","title":"missing loci"}]}